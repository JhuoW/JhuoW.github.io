<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Notebook on JhuoW‘s Notes</title>
    <link>https://JhuoW.github.io/categories/notebook/</link>
    <description>Recent content in Notebook on JhuoW‘s Notes</description>
    <image>
      <url>https://JhuoW.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://JhuoW.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Apr 2022 16:41:42 +0800</lastBuildDate><atom:link href="https://JhuoW.github.io/categories/notebook/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Proximal Gradient Descent</title>
      <link>https://JhuoW.github.io/posts/pgd/</link>
      <pubDate>Mon, 04 Apr 2022 16:41:42 +0800</pubDate>
      
      <guid>https://JhuoW.github.io/posts/pgd/</guid>
      <description>当目标函数中有不可微部分时，可使用近端梯度下降来优化（Proximal Gradient Descent）
假设目标函数如下： $$ \definecolor{energy}{RGB}{114,0,172} \definecolor{freq}{RGB}{45,177,93} \definecolor{spin}{RGB}{251,0,29} \definecolor{signal}{RGB}{18,110,213} \definecolor{circle}{RGB}{217,86,16} \definecolor{average}{RGB}{203,23,206} \definecolor{red}{RGB}{255,0,0} f(w) = g(w) + h(w) $$ 其中$g(w)$是可微凸函数，$h(w)$是不可微（或局部不可微）凸函数。 以线性回归为例，
给定$X \in \mathbb{R}^{m \times n}$, $y \in \mathbb{R}^m$， Ridge Regression的目标函数为
$$ f(\boldsymbol{w})=\underbrace{\frac{1}{2}||\boldsymbol{y}-\boldsymbol{X} \boldsymbol{w}||_{2}^{2}}_{g(\boldsymbol{w})}+\underbrace{\lambda||\boldsymbol{w}||_{2}}_{h(\boldsymbol{w})} $$ 因为$\ell_2$ norm处处可导，所以Ridge可以用SGD或GD来直接优化。但是若目标函数为Lasso，即正则化项定义为$\ell_1$ norm: $$ f(\boldsymbol{w})=\underbrace{\frac{1}{2}||\boldsymbol{y}-\boldsymbol{X} \boldsymbol{w}||_{2}^{2}}_{g(\boldsymbol{w})}+\underbrace{\lambda||\boldsymbol{w}||_{1}}_{h(\boldsymbol{w})} $$ 这里$h(w)=\lambda||\boldsymbol{w}||_{1}$在$w=0$处不可导，那么可用PGD来优化。
Proximity Operator 近端算子： 对于不可微函数$h(w)$, $h(w)$的proximity operator定义为：
$$ u^* = \operatorname{prox}_{\color{signal}h}(w)=\underset{u}{\arg \min }\left(h(u)+\frac{1}{2}||u-w||_{2}^{2}\right) $$ 近端算子$\operatorname{prox}_{\color{signal}h}(w)$只和不可微凸函数$h(\cdot)$有关。 上式含义，给定一个不可微凸函数$h(\cdot)$, 给定向量$w \in \mathbb{R}^n$, 找到向量$u = u^*$, 使得公式$h(u)+\frac{1}{2}||u-w||_{2}^{2}$最小。 这个$u^* = \operatorname{prox}_{\color{signal}h}(w)$就是$h(\cdot)$在给定$w$条件下的近端算子（Proximity Operator）。$u^* = \operatorname{prox}_{\color{signal}h}(w)$要求最佳的$u^* $可以使得函数值$h(u^*)$尽可能小，同时$u^*$要尽可能接近给定的$w$。</description>
      <content:encoded><![CDATA[<p>当目标函数中有不可微部分时，可使用近端梯度下降来优化（Proximal Gradient Descent）</p>
<p>假设目标函数如下：
$$
\definecolor{energy}{RGB}{114,0,172}
\definecolor{freq}{RGB}{45,177,93}
\definecolor{spin}{RGB}{251,0,29}
\definecolor{signal}{RGB}{18,110,213}
\definecolor{circle}{RGB}{217,86,16}
\definecolor{average}{RGB}{203,23,206}
\definecolor{red}{RGB}{255,0,0}
f(w) = g(w) + h(w)
$$
其中$g(w)$是可微凸函数，$h(w)$是不可微（或局部不可微）凸函数。 以线性回归为例，</p>
<p>给定$X \in \mathbb{R}^{m \times n}$, $y \in \mathbb{R}^m$， Ridge Regression的目标函数为</p>
<p>$$
f(\boldsymbol{w})=\underbrace{\frac{1}{2}||\boldsymbol{y}-\boldsymbol{X} \boldsymbol{w}||_{2}^{2}}_{g(\boldsymbol{w})}+\underbrace{\lambda||\boldsymbol{w}||_{2}}_{h(\boldsymbol{w})}
$$
因为$\ell_2$ norm处处可导，所以Ridge可以用SGD或GD来直接优化。但是若目标函数为Lasso，即正则化项定义为$\ell_1$ norm:
$$
f(\boldsymbol{w})=\underbrace{\frac{1}{2}||\boldsymbol{y}-\boldsymbol{X} \boldsymbol{w}||_{2}^{2}}_{g(\boldsymbol{w})}+\underbrace{\lambda||\boldsymbol{w}||_{1}}_{h(\boldsymbol{w})}
$$
这里$h(w)=\lambda||\boldsymbol{w}||_{1}$在$w=0$处不可导，那么可用PGD来优化。</p>
<h1 id="proximity-operator">Proximity Operator</h1>
<p>近端算子： 对于不可微函数$h(w)$, $h(w)$的proximity operator定义为：</p>
<p>$$
u^* = \operatorname{prox}_{\color{signal}h}(w)=\underset{u}{\arg \min }\left(h(u)+\frac{1}{2}||u-w||_{2}^{2}\right)
$$
近端算子$\operatorname{prox}_{\color{signal}h}(w)$只和不可微凸函数$h(\cdot)$有关。 上式含义，给定一个不可微凸函数$h(\cdot)$, 给定向量$w \in \mathbb{R}^n$, 找到向量$u = u^*$, 使得公式$h(u)+\frac{1}{2}||u-w||_{2}^{2}$最小。 这个$u^* = \operatorname{prox}_{\color{signal}h}(w)$就是$h(\cdot)$在给定$w$条件下的近端算子（Proximity Operator）。$u^* = \operatorname{prox}_{\color{signal}h}(w)$要求最佳的$u^* $可以使得函数值$h(u^*)$尽可能小，同时$u^*$要尽可能接近给定的$w$。</p>
<p>基于后面的公式推导，我们给$\operatorname{prox}_{\color{signal}h}(w)$添加一个参数$\color{energy}\gamma$:
$$
u^* = \operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w)=\underset{u}{\arg \min }\left(h(u)+\frac{1}{2\color{energy}\gamma}||u-w||_{2}^{2}\right)
$$
上式表示，给定一个不可微凸函数$h(\cdot)$， 一个给定的点$w$, 一个参数$\gamma$, 要找到一个$u = u^*$, 使得$u^*$带入公式$h(u)+\frac{1}{2\color{energy}\gamma}||u-w||_{2}^{2}$的到的结果最小。 $\operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w)$是使得$h(u)+\frac{1}{2\color{energy}\gamma}||u-w||_{2}^{2}$最小的输入$u$。</p>
<p>因为$h(u)$和$||u-w||_{2}^{2}$都为凸函数，所以一定存在$u^*$使得函数值最小， 这个$u^* = \operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w)$要求使得$h(u^*)$尽可能小（第一项），同时$u^*$要尽可能接近给定的$w$（第二项）。</p>
<p>例子：</p>
<ul>
<li>
<p>若$h(w)=0$, $\operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w) = u^* = w$。</p>
</li>
<li>
<p>当$h(w) = ||w||_{1}$时，$\operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w) = \operatorname{prox}_{\color{signal}||\cdot||_{1}\color{energy}\gamma}(w)$是软阈值操作</p>
</li>
</ul>
<p>$$
u^* = \left(\operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w)\right)_{i}= \begin{cases}w_{i}-\gamma &amp; w_{i} \geq \gamma \\ 0 &amp; \left|\mathrm{w}_{i}\right| \leq \gamma \\ w_{i}+ \gamma &amp; w_{i} \leq-\gamma\end{cases}
$$</p>
<p>如果在$\ell_1$ norm前加上参数$\lambda$， 即$h(w) = \lambda||w||_{1}$， 那么近端算子为：
$$
u^* = \left(\operatorname{prox}_{\color{signal}h\color{energy}\gamma}(w)\right)_{i}= \begin{cases}w_{i}-\lambda\gamma &amp; w_{i} \geq \lambda\gamma \\ 0 &amp; \left|\mathrm{w}_{i}\right| \leq \lambda\gamma \\ w_{i}+ \lambda\gamma &amp; w_{i} \leq-\lambda\gamma\end{cases}
$$</p>
<h1 id="近端梯度算法">近端梯度算法</h1>
<p>回到Lasso 回归，要求解：
$$
\min_{w}(g(w)+h(w))
$$
$w$可以通过递推式求出：
$$
\boldsymbol{w}^{k}=\operatorname{prox}_{\color{signal}h\color{energy}\gamma}\left(\boldsymbol{w}^{k-1}-\gamma \nabla g\left(\boldsymbol{w}^{k-1}\right)\right)
$$
为什么可以通过不断迭代迭代上式来求解最佳的$w^{K}$, 使得$g(w)+h(w)$收敛到最小？下面先给出证明
$$
\begin{equation}
\begin{aligned}
\boldsymbol{w}^{k} &amp; =\operatorname{prox}_{\color{signal}h\color{energy}\gamma}\left(\boldsymbol{w}^{k-1}-\gamma \nabla g\left(\boldsymbol{w}^{k-1}\right)\right)\\
&amp;=\underset{u}{\operatorname{argmin}}\left(\underbrace{h(u)}_{\color{red}h(u)尽可能小}+\frac{1}{2 \gamma}\left|\left|\underbrace{u-\left(w^{k-1}-\gamma \nabla g\left(w^{k-1}\right)\right)}_{\color{red}u尽可能接近w^{k-1}-\gamma \nabla g\left(w^{k-1}\right)}\right|\right|_{2}^{2}\right)\\
&amp;= \underset{u}{\operatorname{argmin}}\left(h(u)+\frac{1}{2 \gamma}\left|\left|(u-w^{k-1} )+\gamma \nabla g\left(w^{k-1}\right)\right|\right|_{2}^{2}\right)\\
&amp; = \underset{u}{\operatorname{argmin}}\left(h(u)+\underbrace{\frac{\gamma}{2}\left|\left|\nabla g\left(w^{k-1}\right)\right|\right|_{2}^{2}}_{\color{red}\gamma和w^{k-1}给定， 所以该项与u无关，视为常数，可省略}+\left(u-w^{k-1}\right)^{T}\nabla g\left(w^{k-1}\right)+\frac{1}{2 \gamma}\left|\left|u-w^{k-1}\right|\right|_{2}^{2}\right) \\
&amp;= \underset{u}{\operatorname{argmin}}\left(h(u)+\underbrace{g\left(w^{k-1}\right)}_{\color{red}添加与u无关的项，不影响结果}+\left(u-w^{k-1}\right)^T\nabla g\left(w^{k-1}\right)+\frac{1}{2 \gamma}\left|\left|u-w^{k-1}\right|\right|_{2}^{2}\right) \quad \quad (5)\\ &amp;
\approx \underset{u}{\arg \min }(g(u)+h(u))
\end{aligned}
\end{equation}
$$
<strong>整个过程不涉及对$h(u)$求梯度</strong></p>
<p>最后两步怎么来的？</p>
<blockquote>
<p>泰勒展开式：</p>
<p>$$f(x)=\frac{f\left(a\right)}{0 !}+\frac{f^{\prime}\left(a\right)}{1 !}\left(x-a\right)+\frac{f^{\prime \prime}\left(a\right)}{2 !}\left(x-a\right)^{2}+\ldots+\frac{f^{(n)}\left(a\right)}{n !}\left(x-a\right)^{n}$$</p>
</blockquote>
<p>对$g(u)$做泰勒展开， 令$a=w^{k-1}$:
$$
\begin{equation}
\begin{aligned}
g(u) &amp;= g(w^{k-1}) + (u-w^{k-1})^{T}\nabla g\left(w^{k-1}\right) + \langle u-w^{k-1}, u-w^{k-1}\rangle \nabla^2 g\left(w^{k-1}\right) \\
&amp; \approx (5)式最后三项
\end{aligned}
\end{equation}
$$
综上：
$$
\begin{equation}
\begin{aligned}
\boldsymbol{w}^{k} &amp; =\operatorname{prox}_{\color{signal}h\color{energy}\gamma}\left(\boldsymbol{w}^{k-1}-\gamma \nabla g\left(\boldsymbol{w}^{k-1}\right)\right) \\
&amp; \approx \underset{u}{\arg \min }(g(u)+h(u))
\end{aligned}
\end{equation}
$$
<strong>所以通过迭代的方式求$w^k = \operatorname{prox}_{\color{signal}h\color{energy}\gamma}\left(\boldsymbol{w}^{k-1}-\gamma \nabla g\left(\boldsymbol{w}^{k-1}\right)\right)$ 就是$\min_{w}(g(w)+h(w))$的迭代递推求解过程。</strong></p>
<h2 id="求解ell_1-范数">求解$\ell_1$ 范数</h2>
<p><strong>将求解问题转为递推式</strong>。</p>
<p>现在我们有问题，形式为：
$$
\min_{w}(\underbrace{g(w)}_{\color{red}凸可微}+\underbrace{\lambda \left|\left| w \right|\right|_1}_{\color{red}h(w)凸不可微})
$$
找到最佳$w$使得上式最小的过程可以迭代递推为：
$$
\begin{equation}
\begin{aligned}
w^{k+1}&amp;=\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}\left(w^{k}-\gamma \nabla g\left(w^{k}\right)\right)\\
&amp;= \underset{u}{\arg \min }\left(\lambda \left|\left| u \right|\right|_1+\frac{1}{2\color{energy}\gamma}||u-\left(w^{k}-\gamma \nabla g\left(w^{k}\right)\right)||_{2}^{2}\right)
\end{aligned}
\end{equation}
$$</p>
<h2 id="求解lasso回归">求解Lasso回归</h2>
<p>待求解问题形如：
$$
\min_{w}\left(\frac{1}{2}||X w-y||_{2}^{2}+r||w||_1\right)
$$
可见第一项可微，第二项为$\ell_1$ norm 在$w=0$处不可微。</p>
<p>根据递推式：
$$
w^{k+1}=\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}\left(\underbrace{w^{k}-\gamma \nabla g\left(w^{k}\right)}_{\color{red}z^k}\right)
$$
令$z^k = w^{k}-\gamma \nabla g\left(w^{k}\right)$, 上式可改写为</p>
<p>因为learning step size $\gamma$ 与$w$无关，所以上式可以改写为：
$$
\begin{equation}
\begin{aligned}
w^{k+1}&amp;=\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}\left(z^k\right)\\
&amp;= \underset{w}{\arg \min } \left(  \lambda \left|\left| w \right|\right|_1 + \frac{1}{2\color{energy}\gamma}||w-z^k||_{2}^{2}\right) \\
&amp;= \underset{w}{\arg \min } \left(  \lambda \gamma\left|\left| w \right|\right|_1 + \frac{1}{2}||w-z^k||_{2}^{2}\right)
\end{aligned}
\end{equation}
$$</p>
<p>$\because g(w^k) = \frac{1}{2}||X w-y||_{2}^{2}$</p>
<p>$\therefore \nabla g(w^k) = X^{T}(Xw^k-y) = X^TXw^k-X^Ty$</p>
<p>$\therefore z^k = w^k-\gamma (X^TXw^k-X^Ty)$</p>
<p>把$z^k$带入$w^{k+1}$中：
$$
\begin{equation}
\begin{aligned}
w^{k+1}&amp;=\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}\left(z^k\right)\\
&amp;=\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}\left( w^k-\gamma X^TXw^k+ \gamma X^Ty\right)
\end{aligned}
\end{equation}
$$
因为$\left(\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}(w)\right)_{i}= \begin{cases}w_{i}-\lambda\gamma &amp; w_{i} \geq \lambda\gamma \\ 0 &amp; \left|w_{i}\right| \leq \lambda\gamma \\ w_{i}+ \lambda\gamma &amp; w_{i} \leq-\lambda\gamma\end{cases}$,</p>
<p>所以$w^k$到$w^{k+1}$的迭代优化方式如下：
$$
w_i^{k+1} = \left(\operatorname{prox}_{\color{signal}\lambda||\cdot||_{1}\color{energy}\gamma}\left( z^k\right)\right)_i = \begin{cases} z^k_{i}-\lambda\gamma &amp; z^k_{i} \geq \lambda\gamma \\ 0 &amp; \left|z^k_{i}\right| \leq \lambda\gamma \\ z^k_{i}+ \lambda\gamma &amp; z^k_{i} \leq-\lambda\gamma \end{cases}
$$
其中 $z^k_{i}$是$z^k$的第$i$行。</p>
<h1 id="reference">Reference</h1>
<p><a href="https://blog.csdn.net/Chaolei3/article/details/81320940">https://blog.csdn.net/Chaolei3/article/details/81320940</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/82622940">https://zhuanlan.zhihu.com/p/82622940</a></p>
<p><a href="http://roachsinai.github.io/2016/08/03/1Proximal_Method/">http://roachsinai.github.io/2016/08/03/1Proximal_Method/</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Everything about Graph Laplacian</title>
      <link>https://JhuoW.github.io/posts/laplacian/</link>
      <pubDate>Sat, 02 Apr 2022 15:00:20 +0800</pubDate>
      
      <guid>https://JhuoW.github.io/posts/laplacian/</guid>
      <description>Introduction The spectral graph theory studies the properties of graphs via the eigenvalues and eigenvectors of their associated graph matrices: the adjacency matrix and the graph Laplacian and its variants. The Laplacian allows a natural link between discrete representations, such as graphs, and continuous representations, such as vector spaces and manifolds. The most important application of the Laplacian is spectral clustering that corresponds to a computationally tractable solution to the graph partitionning problem.</description>
      <content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>The spectral graph theory studies the properties of graphs via the eigenvalues and eigenvectors of their associated graph matrices: the adjacency matrix and the graph Laplacian and its variants. The Laplacian allows a natural link between discrete representations, such as graphs, and continuous representations, such as vector spaces and manifolds.  The most important application of the Laplacian is spectral clustering that corresponds to a computationally tractable solution to the graph partitionning problem. Another application is spectral matching that solves for graph matching.</p>
<h1 id="basic-notations">Basic notations</h1>
<p>We consider simple graphs (no multiple edges or loops), $\mathcal{G}=(\mathcal{V}, \mathcal{E})$ :</p>
<ul>
<li>
<p>$\mathcal{V}(\mathcal{G})=\left\{v_{1}, \ldots, v_{n}\right\}$ is called the vertex set with $n=|\mathcal{V}|$;</p>
</li>
<li>
<p>$\mathcal{E}(\mathcal{G})=\left\{e_{i j}\right\}$ is called the edge set with $m=|\mathcal{E}|$;</p>
</li>
<li>
<p>An edge $e_{i j}$ connects vertices $v_{i}$ and $v_{j}$ if they are adjacent or neighbors. One possible notation for adjacency is $v_{i} \sim v_{j}$;</p>
</li>
<li>
<p>The number of neighbors of a node $v$ is called the degree of $v$ and is denoted by $d(v), d\left(v_{i}\right)=\sum_{v_{i} \sim v_{j}} e_{i j}$. If all the nodes of a graph have the same degree, the graph is regular; The nodes of an Eulerian graph have even degree.</p>
</li>
<li>
<p>A graph is complete if there is an edge between every pair of vertices.</p>
</li>
</ul>
<h1 id="subgraph-of-a-graph">Subgraph of a graph</h1>
<ul>
<li>
<p>$\mathcal{H}$ is a subgraph of $\mathcal{G}$ if $\mathcal{V}(\mathcal{H}) \subseteq \mathcal{V}(\mathcal{G})$ and $\mathcal{E}(\mathcal{H}) \subseteq \mathcal{E}(\mathcal{G})$;</p>
</li>
<li>
<p>a subgraph $\mathcal{H}$ is an induced subgraph of $\mathcal{G}$ if two vertices of $\mathcal{V}(\mathcal{H})$ are adjacent if and only if they are adjacent in $\mathcal{G}$.</p>
</li>
<li>
<p>A clique is a complete subgraph of a graph.</p>
</li>
<li>
<p>A path of $k$ vertices is a sequence of $k$ distinct vertices such that consecutive vertices are adjacent.</p>
</li>
<li>
<p>A cycle is a connected subgraph where every vertex has exactly two neighbors.</p>
</li>
<li>
<p>A graph containing no cycles is a forest. A connected forest is a tree.</p>
</li>
</ul>
<h1 id="a-k-partite-graph">A k-partite graph</h1>
<ul>
<li>A graph is called k-partite if its set of vertices admits a partition into $k$ classes such that the vertices of the same class are not adjacent.</li>
<li>An example of a bipartite graph.</li>
</ul>
<p><img loading="lazy" src="/posts/2022-04-02-laplacian/1.png#center" alt="你想输入的替代文字"  />
</p>
<h1 id="the-adjacency-matrix-of-a-graph">The adjacency matrix of a graph</h1>
<ul>
<li>For a graph with $n$ vertices, the entries of the $n \times n$ adjacency matrix are defined by:</li>
</ul>
<p>$$
\mathbf{A}:= \begin{cases}A_{i j}=1 &amp; \text { if there is an edge } e_{i j} \\ A_{i j}=0 &amp; \text { if there is no edge } \\ A_{i i}=0 &amp; \end{cases}
$$</p>
<p>$$
\begin{aligned}
&amp; \mathbf{A}=\left[\begin{array}{llll}0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0\end{array}\right]
\end{aligned}
$$</p>
<p><img loading="lazy" src="/posts/2022-04-02-laplacian/2.png#center" alt="你想输入的替代文字"  />
</p>
<h1 id="eigenvalues-and-eigenvectors">Eigenvalues and eigenvectors</h1>
<ul>
<li>
<p>A is a real-symmetric matrix: it has $n$ real eigenvalues and its $n$ real eigenvectors form an orthonormal basis.</p>
</li>
<li>
<p>Let $\left\{\lambda_{1}, \ldots, \lambda_{i}, \ldots, \lambda_{r}\right\}$ be the set of distinct eigenvalues.</p>
</li>
<li>
<p>The eigenspace $S_{i}$ contains the eigenvectors associated with $\lambda_{i}$ :</p>
</li>
</ul>
<p>$$
S_{i}=\left\{\boldsymbol{x} \in \mathbb{R}^{n} \mid \mathbf{A} \boldsymbol{x}=\lambda_{i} \boldsymbol{x}\right\}
$$</p>
<ul>
<li>
<p>For real-symmetric matrices, the algebraic multiplicity is equal to the geometric multiplicity, for all the eigenvalues.</p>
</li>
<li>
<p>The dimension of $S_{i}$ (geometric multiplicity) is equal to the multiplicity of $\lambda_{i}$.</p>
</li>
<li>
<p>If $\lambda_{i} \neq \lambda_{j}$ then $S_{i}$ and $S_{j}$ are mutually orthogonal.</p>
</li>
</ul>
<h1 id="real-valued-functions-on-graphs">Real-valued functions on graphs</h1>
<ul>
<li>
<p>We consider real-valued functions on the set of the graph&rsquo;s vertices, $\boldsymbol{f}: \mathcal{V} \longrightarrow \mathbb{R}$. Such a function assigns a real number to each graph node.</p>
</li>
<li>
<p>$\boldsymbol{f}$ is a vector indexed by the graph&rsquo;s vertices, hence $\boldsymbol{f} \in \mathbb{R}^{n}$.</p>
</li>
<li>
<p>Notation: $\boldsymbol{f}=\left(f\left(v_{1}\right), \ldots, f\left(v_{n}\right)\right)=(f(1), \ldots, f(n))$.</p>
</li>
<li>
<p>The eigenvectors of the adjacency matrix, $\mathbf{A} \boldsymbol{x}=\lambda \boldsymbol{x}$, can be viewed as eigenfunctions.</p>
</li>
</ul>
<p><img loading="lazy" src="/posts/2022-04-02-laplacian/3.png#center" alt="你想输入的替代文字"  />
</p>
<h1 id="matrix-a-as-an-operator-and-quadratic-form">Matrix A as an operator and quadratic form</h1>
<ul>
<li>The adjacency matrix can be viewed as an operator</li>
</ul>
<p>$$
\boldsymbol{g}=\mathbf{A} \boldsymbol{f} ; g(i)=\sum_{i \sim j} f(j)
$$</p>
<ul>
<li>It can also be viewed as a quadratic form:</li>
</ul>
<p>$$
\boldsymbol{f}^{\top} \mathbf{A} \boldsymbol{f}=\sum_{e_{i j}} f(i) f(j)
$$</p>
<h1 id="the-incidence-matrix-of-a-graph">The incidence matrix of a graph</h1>
<ul>
<li>
<p>Let each edge in the graph have an arbitrary but fixed orientation;</p>
</li>
<li>
<p>The incidence matrix of a graph is a $|\mathcal{E}| \times|\mathcal{V}|(m \times n)$ matrix defined as follows:</p>
</li>
</ul>
<p>$$
\nabla:= \begin{cases}\nabla_{e v}=-1 &amp; \text { if } v \text { is the initial vertex of edge } e \\ \nabla_{e v}=1 &amp; \text { if } v \text { is the terminal vertex of edge } e \\ \nabla_{e v}=0 &amp; \text { if } v \text { is not in } e\end{cases}
$$</p>
<p>$$
\begin{aligned}
&amp; \nabla=\left[\begin{array}{cccc}-1 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; -1 &amp; 0 \\0 &amp; -1 &amp; 1 &amp; 0 \\0 &amp; -1 &amp; 0 &amp; +1\end{array}\right]
\end{aligned}
$$</p>
<p><img loading="lazy" src="/posts/2022-04-02-laplacian/2.png#center" alt="你想输入的替代文字"  />
</p>
<h1 id="the-incidence-matrix-a-discrete-differential-operator">The incidence matrix: A discrete differential operator</h1>
<ul>
<li>
<p>The mapping $\boldsymbol{f} \longrightarrow \nabla \boldsymbol{f}$ is known as the co-boundary mapping of the graph.</p>
</li>
<li>
<p>$(\nabla \boldsymbol{f})\left(e_{i j}\right)=f\left(v_{j}\right)-f\left(v_{i}\right)$</p>
</li>
</ul>
<p>$$
\left(\begin{array}{c}
f(2)-f(1) \\
f(1)-f(3) \\
f(3)-f(2) \\
f(4)-f(2)
\end{array}\right)=\left[\begin{array}{cccc}
-1 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; -1 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0 &amp; +1
\end{array}\right]\left(\begin{array}{c}
f(1) \\
f(2) \\
f(3) \\
f(4)
\end{array}\right)
$$</p>
<h1 id="the-laplacian-matrix-of-a-graph">The Laplacian matrix of a graph</h1>
<ul>
<li>
<p>$\mathbf{L}=\nabla^{\top} \nabla$</p>
</li>
<li>
<p>$(\mathbf{L} \boldsymbol{f})\left(v_{i}\right)=\sum_{v_{j} \sim v_{i}}\left(f\left(v_{i}\right)-f\left(v_{j}\right)\right)$</p>
</li>
<li>
<p>Connection between the Laplacian and the adjacency matrices:</p>
</li>
</ul>
<p>$$
\mathbf{L}=\mathbf{D}-\mathbf{A}
$$</p>
<ul>
<li>The degree matrix: $\mathbf{D}:=D_{i i}=d\left(v_{i}\right)$.</li>
</ul>
<p>$$
\mathbf{L}=\left[\begin{array}{cccc}
2 &amp; -1 &amp; -1 &amp; 0 \\
-1 &amp; 3 &amp; -1 &amp; -1 \\
-1 &amp; -1 &amp; 2 &amp; 0 \\
0 &amp; -1 &amp; 0 &amp; 1
\end{array}\right]
$$</p>
<h1 id="the-laplacian-matrix-of-an-undirected-weighted-graph">The Laplacian matrix of an undirected weighted graph</h1>
<ul>
<li>
<p>We consider undirected weighted graphs: Each edge $e_{i j}$ is weighted by $w_{i j}&gt;0$.</p>
</li>
<li>
<p>The Laplacian as an operator:</p>
</li>
</ul>
<p>$$
(\mathbf{L} \boldsymbol{f})\left(v_{i}\right)=\sum_{v_{j} \sim v_{i}} w_{i j}\left(f\left(v_{i}\right)-f\left(v_{j}\right)\right)
$$</p>
<ul>
<li>As a quadratic form:</li>
</ul>
<p>$$
\boldsymbol{f}^{\top} \mathbf{L} \boldsymbol{f}=\frac{1}{2} \sum_{e_{i j}} w_{i j}\left(f\left(v_{i}\right)-f\left(v_{j}\right)\right)^{2}
$$</p>
<ul>
<li>
<p>L is symmetric and positive semi-definite.</p>
</li>
<li>
<p>L has $n$ non-negative, real-valued eigenvalues: $0=\lambda_{1} \leq \lambda_{2} \leq \ldots \leq \lambda_{n} .$</p>
</li>
</ul>
<h1 id="the-laplacian-of-a-3d-discrete-surface-mesh">The Laplacian of a 3D discrete surface (mesh)</h1>
<ul>
<li>
<p>A graph vertex $v_{i}$ is associated with a 3D point $\boldsymbol{v}_{i}$.</p>
</li>
<li>
<p>The weight of an edge $e_{i j}$ is defined by the Gaussian kernel:</p>
</li>
</ul>
<p>$$
w_{i j}=\exp \left(-\left|\boldsymbol{v}_{i}-\boldsymbol{v}_{j}\right|^{2} / \sigma^{2}\right)
$$</p>
<ul>
<li>
<p>$0 \leq w_{\min } \leq w_{i j} \leq w_{\max } \leq 1$</p>
</li>
<li>
<p>Hence, the geometric structure of the mesh is encoded in the weights.</p>
</li>
<li>
<p>Other weighting functions were proposed in the literature.</p>
</li>
</ul>
<h1 id="the-laplacian-of-a-cloud-of-points">The Laplacian of a cloud of points</h1>
<ul>
<li>
<p>3-nearest neighbor graph</p>
</li>
<li>
<p>$\varepsilon$-radius graph</p>
</li>
<li>
<p>KNN may guarantee that the graph is connected (depends on the implementation)</p>
</li>
<li>
<p>$\varepsilon$-radius does not guarantee that the graph has one connected component</p>
</li>
</ul>
<p><img loading="lazy" src="/posts/2022-04-02-laplacian/4.png#center" alt="你想输入的替代文字"  />
</p>
<h1 id="the-laplacian-of-a-graph-with-one-connected-component">The Laplacian of a graph with one connected component</h1>
<ul>
<li>
<p>$Lu =\lambda \boldsymbol{u}$.</p>
</li>
<li>
<p>$\mathbf{L} \mathbf{1}_{n}=\mathbf{0}, \lambda_{1}=0$ is the smallest eigenvalue.</p>
</li>
<li>
<p>The one vector: $\mathbf{1}_{n}=(1 \ldots 1)^{\top}$.</p>
</li>
<li>
<p>$0=\boldsymbol{u}^{\top} \mathbf{L} \boldsymbol{u}=\sum_{i, j=1}^{n} w_{i j}(u(i)-u(j))^{2}$.</p>
</li>
<li>
<p>If any two vertices are connected by a path, then $\boldsymbol{u}=(u(1), \ldots, u(n))$ needs to be constant at all vertices such that the quadratic form vanishes. Therefore, a graph with one connected component has the constant vector $\boldsymbol{u}_{1}=\mathbf{1}_{n}$ as the only eigenvector with eigenvalue 0 .</p>
</li>
</ul>
<h1 id="a-graph-with-k1-connected-components">A graph with $k&gt;1$ connected components</h1>
<ul>
<li>Each connected component has an associated Laplacian. Therefore, we can write matrix $\mathbf{L}$ as a block diagonal matrix:</li>
</ul>
<p>$$
\mathbf{L}=\left[\begin{array}{lll}
\mathbf{L}_{1} &amp; &amp; \\
&amp; \ddots &amp; \\
&amp; &amp; \mathbf{L}_{k}
\end{array}\right]
$$</p>
<ul>
<li>
<p>The spectrum of $\mathbf{L}$ is given by the union of the spectra of $\mathbf{L}_{i}$.</p>
</li>
<li>
<p>Each block corresponds to a connected component, hence each matrix $\mathbf{L}_{i}$ has an eigenvalue 0 with multiplicity 1 .</p>
</li>
<li>
<p>The spectrum of $\mathbf{L}$ is given by the union of the spectra of $\mathbf{L}_{i}$.</p>
</li>
<li>
<p>The eigenvalue $\lambda_{1}=0$ has multiplicity $k$.</p>
</li>
</ul>
<h1 id="the-eigenspace-of-lambda_10-with-multiplicity-k">The eigenspace of $\lambda_{1}=0$ with multiplicity $k$</h1>
<ul>
<li>The eigenspace corresponding to $\lambda_{1}=\ldots=\lambda_{k}=0$ is spanned by the $k$ mutually orthogonal vectors:</li>
</ul>
<p>$$
\begin{aligned}
\boldsymbol{u}_{1} &amp;=\mathbf{1}_{L_{1}} \\
&amp; \cdots \\
\boldsymbol{u}_{k} &amp;=\mathbf{1}_{L_{k}}
\end{aligned}
$$</p>
<ul>
<li>
<p>with $\mathbf{1}_{L_{i}}=(0000111110000)^{\top} \in \mathbb{R}^{n}$</p>
</li>
<li>
<p>These vectors are the indicator vectors of the graph&rsquo;s connected components.</p>
</li>
<li>
<p>Notice that $\mathbf{1}_{L_{1}}+\ldots+\mathbf{1}_{L_{k}}=\mathbf{1}_{n}$</p>
</li>
</ul>
<h1 id="the-fiedler-vector-of-the-graph-laplacian">The Fiedler vector of the graph Laplacian</h1>
<ul>
<li>
<p>The first non-null eigenvalue $\lambda_{k+1}$ is called the Fiedler value.</p>
</li>
<li>
<p>The corresponding eigenvector $\boldsymbol{u}_{k+1}$ is called the Fiedler vector.</p>
</li>
<li>
<p>The multiplicity of the Fiedler eigenvalue is always equal to $1 .$</p>
</li>
<li>
<p>The Fiedler value is the algebraic connectivity of a graph, the further from 0 , the more connected.</p>
</li>
<li>
<p>The Fidler vector has been extensively used for spectral bi-partioning</p>
</li>
<li>
<p>Theoretical results are summarized in Spielman &amp; Teng 2007: <a href="http://cs-www.cs.yale.edu/homes/spielman/">http://cs-www.cs.yale.edu/homes/spielman/</a></p>
</li>
</ul>
<h1 id="eigenvectors-of-the-laplacian-of-connected-graphs">Eigenvectors of the Laplacian of connected graphs</h1>
<ul>
<li>
<p>$\boldsymbol{u}_{1}=\mathbf{1}_{n}, \mathbf{L} \mathbf{1}_{n}=\mathbf{0}$.</p>
</li>
<li>
<p>$\boldsymbol{u}_{2}$ is the the Fiedler vector with multiplicity 1 .</p>
</li>
<li>
<p>The eigenvectors form an orthonormal basis: $\boldsymbol{u}_{i}^{\top} \boldsymbol{u}_{j}=\delta_{i j}$.</p>
</li>
<li>
<p>For any eigenvector $\boldsymbol{u}_{i}=\left(\boldsymbol{u}_{i}\left(v_{1}\right) \ldots \boldsymbol{u}_{i}\left(v_{n}\right)\right)^{\top}, 2 \leq i \leq n$ :</p>
</li>
</ul>
<p>$$
\boldsymbol{u}_{i}^{\top} \mathbf{1}_{n}=0
$$</p>
<ul>
<li>Hence the components of $\boldsymbol{u}_{i}, 2 \leq i \leq n$ satisfy:</li>
</ul>
<p>$$
\sum_{j=1}^{n} \boldsymbol{u}_{i}\left(v_{j}\right)=0
$$</p>
<ul>
<li>Each component is bounded by:</li>
</ul>
<p>$$
-1&lt;\boldsymbol{u}_{i}\left(v_{j}\right)&lt;1
$$</p>
<h1 id="laplacian-embedding-mapping-a-graph-on-a-line">Laplacian embedding: Mapping a graph on a line</h1>
<ul>
<li>Map a weighted graph onto a line such that connected nodes stay as close as possible, i.e., minimize $\sum_{i, j=1}^{n} w_{i j}\left(f\left(v_{i}\right)-f\left(v_{j}\right)\right)^{2}$, or:</li>
</ul>
<p>$$
\arg \min _{\boldsymbol{f}} \boldsymbol{f}^{\top} \mathbf{L} \boldsymbol{f} \text { with: } \boldsymbol{f}^{\top} \boldsymbol{f}=1 \text { and } \boldsymbol{f}^{\top} \mathbf{1}=0
$$</p>
<ul>
<li>
<p>The solution is the eigenvector associated with the smallest nonzero eigenvalue of the eigenvalue problem: $\mathbf{L} \boldsymbol{f}=\lambda \boldsymbol{f}$, namely the Fiedler vector $\boldsymbol{u}_{2}$.</p>
</li>
<li>
<p>For more details on this minimization see Golub &amp; Van Loan Matrix Computations, chapter 8 (The symmetric eigenvalue problem).</p>
</li>
</ul>
<p><em><strong>Example of mapping a graph on the Fiedler vector</strong></em>:</p>
<p><img loading="lazy" src="/posts/2022-04-02-laplacian/5.png#center" alt="你想输入的替代文字"  />
</p>
<h1 id="laplacian-embedding">Laplacian embedding</h1>
<ul>
<li>
<p>Embed the graph in a $k$-dimensional Euclidean space. The embedding is given by the $n \times k$ matrix $\mathbf{F}=\left[\boldsymbol{f}_{1} \boldsymbol{f}_{2} \ldots \boldsymbol{f}_{k}\right]$ where the $i$-th row of this matrix $-\boldsymbol{f}^{(i)}-$ corresponds to the Euclidean coordinates of the $i$-th graph node $v_{i}$.</p>
</li>
<li>
<p>We need to minimize:</p>
</li>
</ul>
<p>$$
\arg \min_{\boldsymbol{f}_{1} \ldots} \sum_{k}^{n} \sum_{i, j=1}^{n} w_{i j}\left|\left|\boldsymbol{f}^{(i)}-\boldsymbol{f}^{(j)}\right|\right|^{2} \text { with: } \mathbf{F}^{\top} \mathbf{F}=\mathbf{I}
$$</p>
<ul>
<li>The solution is provided by the matrix of eigenvectors corresponding to the $k$ lowest nonzero eigenvalues of the eigenvalue problem $\mathbf{L} \boldsymbol{f}=\lambda \boldsymbol{f}$.</li>
</ul>
<h1 id="spectral-embedding-using-the-unnormalized-laplacian">Spectral embedding using the unnormalized Laplacian</h1>
<ul>
<li>
<p>Compute the eigendecomposition $\mathbf{L}=\mathbf{D}-\mathbf{A}$.</p>
</li>
<li>
<p>Select the $k$ smallest non-null eigenvalues $\lambda_{2} \leq \ldots \leq \lambda_{k+1}$</p>
</li>
<li>
<p>$\lambda_{k+2}-\lambda_{k+1}=$ eigengap.</p>
</li>
<li>
<p>We obtain the $n \times k$ matrix $\mathbf{U}=\left[\boldsymbol{u}_{2} \ldots \boldsymbol{u}_{k+1}\right]$ :</p>
</li>
</ul>
<p>$$
\mathbf{U}=\left[\begin{array}{ccc}
\boldsymbol{u}_{2}\left(v_{1}\right) &amp; \ldots &amp; \boldsymbol{u}_{k+1}\left(v_{1}\right) \\
\vdots &amp; &amp; \vdots \\
\boldsymbol{u}_{2}\left(v_{n}\right) &amp; \ldots &amp; \boldsymbol{u}_{k+1}\left(v_{n}\right)
\end{array}\right]
$$</p>
<ul>
<li>
<p>$\boldsymbol{u}_{i}^{\top} \boldsymbol{u}_{j}=\delta_{i j}$ (orthonormal vectors), hence $\mathbf{U}^{\top} \mathbf{U}=\mathbf{I}_{k}$.</p>
</li>
<li>
<p>Column $i(2 \leq i \leq k+1)$ of this matrix is a mapping on the eigenvector $\boldsymbol{u}_{i}$.</p>
</li>
</ul>
<h1 id="euclidean-l-embedding-of-the-graphs-vertices">Euclidean L-embedding of the graph&rsquo;s vertices</h1>
<ul>
<li>(Euclidean) L-embedding of a graph:</li>
</ul>
<p>$$
\mathbf{X}=\boldsymbol{\Lambda}_{k}^{-\frac{1}{2}} \mathbf{U}^{\top}=\left[\begin{array}{llll}
\boldsymbol{x}_{1} &amp; \ldots &amp; \boldsymbol{x}_{j} \ldots &amp; \boldsymbol{x}_{n}
\end{array}\right]
$$</p>
<p>The coordinates of a vertex $v_{j}$ are:</p>
<p>$$
\boldsymbol{x}_{j}=\left(\begin{array}{c}
\frac{\boldsymbol{u}_{2}\left(v_{j}\right)}{\sqrt{\lambda_{2}}} \\
\vdots \\
\frac{\boldsymbol{u}_{k+1}\left(v_{j}\right)}{\sqrt{\lambda_{k+1}}}
\end{array}\right)
$$</p>
<h1 id="justification-for-choosing-the-l-embedding">Justification for choosing the L-embedding</h1>
<p>Both</p>
<ul>
<li>
<p>the commute-time distance (CTD) and</p>
</li>
<li>
<p>the principal-component analysis of a graph (graph PCA)</p>
</li>
</ul>
<p>are two important concepts; They allow to reason &ldquo;statistically&rdquo; on a graph. They are both associated with the unnormalized Laplacian matrix.</p>
<h1 id="the-commute-time-distance">The commute-time distance</h1>
<ul>
<li>
<p>The CTD is a well known quantity in Markov chains;</p>
</li>
<li>
<p>It is the average number of (weighted) edges that it takes, starting at vertex $v_{i}$, to randomly reach vertex $v_{j}$ for the first time and go back;</p>
</li>
<li>
<p>The CTD decreases as the number of connections between the two nodes increases;</p>
</li>
<li>
<p>It captures the connectivity structure of a small graph volume rather than a single path between the two vertices - such as the shortest-path geodesic distance.</p>
</li>
<li>
<p>The CTD can be computed in closed form:</p>
</li>
</ul>
<p>$$
\operatorname{CTD}^{2}\left(v_{i}, v_{j}\right)=\operatorname{vol}(\mathcal{G})\left|\left|\boldsymbol{x}_{i}-\boldsymbol{x}_{j}\right|\right|^{2}
$$</p>
<h1 id="the-graph-pca">The graph PCA</h1>
<ul>
<li>The mean (remember that $\sum_{j=1}^{n} \boldsymbol{u}_{i}\left(v_{j}\right)=0$ ):</li>
</ul>
<p>$$
\overline{\boldsymbol{x}}=\frac{1}{n} \sum_{i=1}^{n} \boldsymbol{x}_{j}=\boldsymbol{\Lambda}_{k}^{-\frac{1}{2}}\left(\begin{array}{c}
\sum_{j=1}^{n} \boldsymbol{u}_{2}\left(v_{j}\right) \\
\vdots \\
\sum_{j=1}^{n} \boldsymbol{u}_{k+1}\left(v_{j}\right)
\end{array}\right)=\left(\begin{array}{c}
0 \\
\vdots \\
0
\end{array}\right)
$$</p>
<ul>
<li>The covariance matrix:</li>
</ul>
<p>$$
\mathbf{S}=\frac{1}{n} \sum_{j=1}^{n} \boldsymbol{x}_{j} \boldsymbol{x}_{j}^{\top}=\frac{1}{n} \mathbf{X} \mathbf{X}^{\top}=\frac{1}{n} \boldsymbol{\Lambda}_{k}^{-\frac{1}{2}} \mathbf{U}^{\top} \mathbf{U} \boldsymbol{\Lambda}_{k}^{-\frac{1}{2}}=\frac{1}{n} \boldsymbol{\Lambda}_{k}^{-1}
$$</p>
<ul>
<li>The vectors $\boldsymbol{u}_{2}, \ldots, \boldsymbol{u}_{k+1}$ are the directions of maximum variance of the graph embedding, with $\lambda_{2}^{-1} \geq \ldots \geq \lambda_{k+1}^{-1}$.</li>
</ul>
<h1 id="other-laplacian-matrices">Other Laplacian matrices</h1>
<ul>
<li>The normalized graph Laplacian (symmetric and semi-definite positive):</li>
</ul>
<p>$$
\mathbf{L}_{n}=\mathbf{D}^{-\frac{1}{2}} \mathbf{L} \mathbf{D}^{-\frac{1}{2}}=\mathbf{I}-\mathbf{D}^{-\frac{1}{2}} \mathbf{A} \mathbf{D}^{-\frac{1}{2}}
$$</p>
<ul>
<li>The transition matrix (allows an analogy with Markov chains):</li>
</ul>
<p>$$
\mathbf{L}_{t}=\mathbf{D}^{-1} \mathbf{A}
$$</p>
<ul>
<li>The random-walk graph Laplacian:</li>
</ul>
<p>$$
\mathbf{L}_{r}=\mathbf{D}^{-1} \mathbf{L}=\mathbf{I}-\mathbf{L}_{t}
$$</p>
<ul>
<li>These matrices are similar:</li>
</ul>
<p>$$
\mathbf{L}_{r}=\mathbf{D}^{-\frac{1}{2}} \mathbf{D}^{-\frac{1}{2}} \mathbf{L} \mathbf{D}^{-\frac{1}{2}} \mathbf{D}^{\frac{1}{2}}=\mathbf{D}^{-\frac{1}{2}} \mathbf{L}_{n} \mathbf{D}^{\frac{1}{2}}
$$</p>
<h1 id="eigenvalues-and-eigenvectors-of-mathrml_n-and-mathrml_r">Eigenvalues and eigenvectors of $\mathrm{L}_{n}$ and $\mathrm{L}_{r}$</h1>
<ul>
<li>$\mathbf{L}_{r} \boldsymbol{w}=\lambda \boldsymbol{w} \Longleftrightarrow \mathbf{L} \boldsymbol{w}=\lambda \mathbf{D} \boldsymbol{w}$, hence:</li>
</ul>
<p>$$
\mathbf{L}_{r}: \quad \lambda_{1}=0 ; \quad \boldsymbol{w}_{1}=\mathbf{1}
$$</p>
<ul>
<li>$\mathbf{L}_{n} \boldsymbol{v}=\lambda \boldsymbol{v}$. By virtue of the similarity transformation between the two matrices:</li>
</ul>
<p>$$
\mathbf{L}_{n}: \quad \lambda_{1}=0 \quad \boldsymbol{v}_{1}=\mathbf{D}^{\frac{1}{2}} \mathbf{1}
$$</p>
<ul>
<li>More generally, the two matrices have the same eigenvalues:</li>
</ul>
<p>$$
0=\lambda_{1} \leq \ldots \leq \lambda_{i} \ldots \leq \lambda_{n}
$$</p>
<ul>
<li>Their eigenvectors are related by:</li>
</ul>
<p>$$
\boldsymbol{v}_{i}=\mathbf{D}^{\frac{1}{2}} \boldsymbol{w}_{i}, \forall i=1 \ldots n
$$</p>
<h1 id="spectral-embedding-using-the-random-walk-laplacian-mathbfl_r">Spectral embedding using the random-walk Laplacian $\mathbf{L}_{r}$</h1>
<ul>
<li>The $n \times k$ matrix contains the first $k$ eigenvectors of $\mathbf{L}_{r}$ :</li>
</ul>
<p>$$
\mathbf{W}=\left[\begin{array}{lll}
\boldsymbol{w}_{2} &amp; \ldots &amp; \boldsymbol{w}_{k+1}
\end{array}\right]
$$</p>
<ul>
<li>It is straightforward to obtain the following expressions, where $\boldsymbol{d}$ and $\mathbf{D}$ are the degree-vector and the degree-matrix:</li>
</ul>
<p>$$
\begin{gathered}
\boldsymbol{w}_{i}^{\top} \boldsymbol{d}=0, \forall i, 2 \leq i \leq n \\
\mathbf{W}^{\top} \mathbf{D W}=\mathbf{I}_{k}
\end{gathered}
$$</p>
<ul>
<li>The isometric embedding using the random-walk Laplacian:</li>
</ul>
<p>$$
\mathbf{Y}=\mathbf{W}^{\top}=\left[\begin{array}{lll}
\boldsymbol{y}_{1} &amp; \ldots &amp; \boldsymbol{y}_{n}
\end{array}\right]
$$</p>
<h1 id="the-normalized-additive-laplacian">The normalized additive Laplacian</h1>
<ul>
<li>Some authors use the following matrix:</li>
</ul>
<p>$$
\mathbf{L}_{a}=\frac{1}{d_{\max }}\left(\mathbf{A}+d_{\max } \mathbf{I}-\mathbf{D}\right)
$$</p>
<ul>
<li>This matrix is closely related to L:</li>
</ul>
<p>$$
\mathbf{L}_{a}=\frac{1}{d_{\max }}\left(d_{\max } \mathbf{I}-\mathbf{L}\right)
$$</p>
<ul>
<li>and we have:</li>
</ul>
<p>$$
\mathbf{L}_{a} \boldsymbol{u}=\mu \boldsymbol{u} \Longleftrightarrow \mathbf{L} \boldsymbol{u}=\lambda \boldsymbol{u}, \mu=1-\frac{\lambda}{d_{\max }}
$$</p>
<h1 id="the-graph-partitioning-problem">The graph partitioning problem</h1>
<ul>
<li>The graph-cut problem: Partition the graph such that:</li>
</ul>
<p>(1) Edges between groups have very low weight, and</p>
<p>(2) Edges within a group have high weight.</p>
<p>$\operatorname{cut}\left(A_{1}, \ldots, A_{k}\right):=\frac{1}{2} \sum_{i=1}^{k} W\left(A_{i}, \bar{A}_{i}\right)$ with $W(A, B)=\sum_{i \in A, j \in B} w_{i j}$</p>
<ul>
<li>Ratio cut:</li>
</ul>
<p>$$
\operatorname{RatioCut}\left(A_{1}, \ldots, A_{k}\right):=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \bar{A}_{i}\right)}{\left|A_{i}\right|}
$$</p>
<ul>
<li>Normalized cut:</li>
</ul>
<p>$$
\operatorname{NCut}\left(A_{1}, \ldots, A_{k}\right):=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \bar{A}_{i}\right)}{\operatorname{vol}\left(A_{i}\right)}
$$</p>
<h1 id="what-is-spectral-clustering">What is spectral clustering?</h1>
<p>See my <a href="https://jhuow.fun/posts/2019-09-07-spectral-clustering/">Blog</a> of Spectral Clustering (in Chinese).</p>
<ul>
<li>
<p>Both ratio-cut and normalized-cut minimizations are NP-hard problems</p>
</li>
<li>
<p>Spectral clustering is a way to solve relaxed versions of these problems:</p>
</li>
</ul>
<p>(1) The smallest non-null eigenvectors of the unnormalized Laplacian approximate the RatioCut minimization criterion, and</p>
<p>(2) The smallest non-null eigenvectors of the random-walk Laplacian approximate the NCut criterion.</p>
<h1 id="spectral-clustering-using-the-random-walk-laplacian">Spectral clustering using the random-walk Laplacian</h1>
<ul>
<li>
<p>For details see (von Luxburg &lsquo;07)</p>
</li>
<li>
<p>Input: Laplacian $\mathbf{L}_{r}$ and the number $k$ of clusters to compute.</p>
</li>
<li>
<p>Output: Cluster $C_{1}, \ldots, C_{k}$.</p>
</li>
</ul>
<p>(3) Compute W formed with the first $k$ eigenvectors of the random-walk Laplacian.</p>
<p>(2) Determine the spectral embedding $\mathbf{Y}=\mathbf{W}^{\top}$</p>
<p>(3) Cluster the columns $\boldsymbol{y}_{j}, j=1, \ldots, n$ into $k$ clusters using the K-means algorithm.</p>
<h1 id="k-means-clustering">K-means clustering</h1>
<p>See Bishop'2006 (pages 424-428) for more details.</p>
<ul>
<li>
<p>What is a cluster: a group of points whose inter-point distance are small compared to distances to points outside the cluster.</p>
</li>
<li>
<p>Cluster centers: $\boldsymbol{\mu}_{1}, \ldots, \boldsymbol{\mu}_{k}$.</p>
</li>
<li>
<p>Goal: find an assignment of points to clusters as well as a set of vectors $\mu_{i}$.</p>
</li>
<li>
<p>Notations: For each point $\boldsymbol{y}_{j}$ there is a binary indicator variable $r_{j i} \in{0,1}$.</p>
</li>
<li>
<p>Objective: minimize the following distorsion measure:</p>
</li>
</ul>
<p>$$
J=\sum_{j=1}^{n} \sum_{i=1}^{k} r_{j i}\left|\left|\boldsymbol{y}_{j}-\boldsymbol{\mu}_{i}\right|\right|^{2}
$$</p>
<h1 id="the-k-means-algorithm">The K-means algorithm</h1>
<p>(1) Initialization: Choose initial values for $\boldsymbol{\mu}_{1}, \ldots, \boldsymbol{\mu}_{k}$.</p>
<p>(2) First step: Assign the $j$-th point to the closest cluster center:</p>
<p>$$
r_{j i}= \begin{cases}1 &amp; \text { if } i=\arg \min_{l}\left|\left|\boldsymbol{y}_{j}-\mu_{l}\right|\right|^{2} \\ 0 &amp; \text { otherwise }\end{cases}
$$</p>
<p>(3) Second Step: Minimize $J$ to estimate the cluster centers:</p>
<p>$$
\boldsymbol{\mu}_{i}=\frac{\sum_{j=1}^{n} r_{j i} \boldsymbol{y}_{j}}{\sum_{j=1}^{n} r_{j i}}
$$</p>
<p>(4) Convergence: Repeat until no more change in the assignments.</p>
<h1 id="the-laplacian-and-the-rayleigh-quotient">The Laplacian and the Rayleigh quotient</h1>
<p>As usual, for a graph $G=(V, E)$, let $A$ be its adjacency matrix and $D$ be the diagonal matrix with $D(v, v)=d_{v}$. Then, the random walk on $G$ will be taken according to the transition matrix $P=D^{-1} A$. We also define the stationary distribution $\pi$ with $\pi(x)=d_{x} / \operatorname{vol} G$.</p>
<p>Our discussion of random walks on $G$ left off with the result</p>
<p>$$
\left|\left|f P^{t}-\pi\right|\right|_{2} \leq \max_{i \neq 0}\left|\rho_{i}\right|^{t} \frac{\max_{x} \sqrt{d_{x}}}{\min_{y} \sqrt{d_{y}}}
$$</p>
<p>where $f$ is a probability distribution (i.e. $f \geq 0$ and $\sum_{x} f(x)=1$ ) and $1=\rho_{0} \geq \rho_{1} \geq \ldots \geq \rho_{n-1}$ are the eigenvalues of $P$. This inequality implies that convergence to the stationary distribution $\pi$ will follow if $\max \left\{\left|\rho_{1}\right|,\left|\rho_{n-1}\right|\right\}&lt;1$.</p>
<p>The transition probability matrix $P$ is similar to the matrix $M=D^{\frac{1}{2}} P D^{-\frac{1}{2}}$, so $P$ and $M$ have the same eigenvalues. We previously introduced the Laplacian of the graph as $\mathcal{L}=I-M$, so it has eigenvalues $0=\lambda_{0} \leq \lambda_{1} \leq \ldots \leq \lambda_{n-1}$ (where $\lambda_{i}=1-\rho_{i}$ ).</p>
<p>The main tool we&rsquo;ll use to study the spectrum of $\mathcal{L}$ is the Rayleigh quotient $R(f)$ of $\mathcal{L}$, defined (for our purposes) as</p>
<p>$$
R(f)=\frac{f L f^{*}}{f D f^{*}}
$$</p>
<p>where $L=D-A$ is the combinatorial Laplacian. This is the same as the usual sense of the Rayleigh quotient $g \mathcal{L} g^{*} / g g^{*}$ with the subtitution $f=g D^{-\frac{1}{2}}$. Following this equivalence, if the $\phi_{i}$ are the eigenvectors of $\mathcal{L}$, we&rsquo;ll call the $\psi_{i}=\phi_{i} D^{-\frac{1}{2}}$ the harmonic eigenvectors of $\mathcal{L}$.</p>
<p>Employing the Rayleigh quotient, we see that the eigenvalue $\lambda_{1}$ can be written as</p>
<p>$$
\lambda_{1}=\inf_{\substack{f \\ \sum_{x} f(x) d_{x}=0}} R(f) .
$$</p>
<p>Since the eigenvector associated with $\lambda_{0}$ is $\phi_{0}=1 D^{\frac{1}{2}}$, the condition $\sum_{x} f(x) d_{x}=0$ is an orthogonality condition. Such variational characterizations can also be made for the other eigenvalues:</p>
<p>$$
\lambda_{n-1}=\sup _{f} R(f)
$$</p>
<p>and, in general,
$$
\lambda_{i}=\sup_{h_{0}, h_{1}, \ldots, h_{i-1}}
\inf_{\substack{f: \\ \sum_{x} f(x) h_{j}(x) d_{x}=0 \\ \forall j \in{0, \ldots, i-1}}}  R(f)
$$
The following characterization of the Rayleigh quotient (demonstrated last time) will be useful later:
$$
R(f)=\frac{\sum_{x \sim y}(f(x)-f(y))^{2}}{\sum_{x} f^{2}(x) d_{x}} .
$$</p>
<p>To this point, we have done a lot of linear algebra. We are not here to teach linear algebra; we are here to take linear algebra one step further to understand what is happening in the graph.</p>
<h1 id="the-cheeger-ratio-and-the-cheeger-constant">The Cheeger Ratio and The Cheeger Constant</h1>
<p>In many areas of mathematics the questions of &ldquo;best&rdquo; comes into play. What is the best bound for a given constant? What is the best way of row reducing a certain matrix? In this section, we will describe a way to make the &ldquo;best possible cut&rdquo; of a graph $G=(V, E)$, where a cut may be either an edge-cut or a vertex-cut, and this cut will split $G$ into two disconnected pieces.</p>
<p>We would like a way to measure the quality of a cut that is made to $G$. That is, would it be better to cut 4 edges which cause us to lose 20 vertices, or is it better to cut 10 edges which would result in the removal of 120 vetices?</p>
<p>Suppose we are given a graph $G=(V, E)$ and a subset $S \subseteq V$. We wish to define the folling two sets:</p>
<p>$$
\partial S={{u, v} \mid u \in S, v \notin S}
$$</p>
<p>and</p>
<p>$$
\delta S={v \notin S \mid v \sim u, u \in S} .
$$</p>
<p>Definition 1 For any vertex set $W$, the volume of $W$ is given by</p>
<p>$$
\operatorname{vol}(W)=\sum_{x W} d_{x},
$$</p>
<p>where $d_{x}$ is the degree of $\mathrm{x}$ in $W$.</p>
<p>Definition 2 The Cheerger Ratio for a vertex set $S$ is</p>
<p>$$
h(S)=\frac{|\partial S|}{\min {\operatorname{vol}(S), \operatorname{vol}(\bar{S})}},
$$</p>
<p>where $\bar{S}=V-S$.</p>
<p>It is first worth noting that in terms of this defintion of the Cheeger ratio, we are gauging the quality of our cut by taking a measure of what&rsquo;s been cut off of $G$. There are other forms of the Cheeger ratio as well. For example, we can use $|\delta S|$ instead of $|\partial S|,|S|($ or $\bar{S})$ instead of $\operatorname{vol}(S)$ (or $\operatorname{vol}(\bar{S}))$, or $|S||\bar{S}|$ instead of $\min {\operatorname{vol}(S), \operatorname{vol}(\bar{S})}$.</p>
<p>Definition 3 For any graph $G=(V, E)$, the Cheeger Constant of $G$ is given by</p>
<p>$$
h_{G}=\min_S h(S) .
$$</p>
<p>Now, if we consider the case where $\operatorname{vol}(S) \leq \frac{1}{2} \operatorname{vol}(G)$, then we can see that</p>
<p>$$
|\partial S| \geq h_{G}(\operatorname{vol}(S)) .
$$</p>
<h1 id="the-cheeger-inequality">The Cheeger Inequality</h1>
<p>Given a graph $G$, we can define $\lambda_{1}$ to be the first nontrivial eignevalue of the Laplacian, $\mathcal{L}$, of $G$.</p>
<p>For any graph $G$,</p>
<p>$$
2 h_{G} \geq \lambda_{1} \geq \frac{h_{G}^{2}}{2}
$$</p>
<h1 id="reference">Reference</h1>
<p><a href="https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf">https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf</a></p>
<p><a href="https://www.microsoft.com/en-us/research/uploads/prod/2006/01/Bishop-Pattern-Recognition-and-Machine-Learning-2006.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2006/01/Bishop-Pattern-Recognition-and-Machine-Learning-2006.pdf</a></p>
<p><a href="https://mathweb.ucsd.edu/~fan/teach/262/notes/paul/10_5_notes.pdf">https://mathweb.ucsd.edu/~fan/teach/262/notes/paul/10_5_notes.pdf</a></p>
<p><a href="https://mathweb.ucsd.edu/~fan/teach/262/notes/paul/10_5_notes.pdf">https://mathweb.ucsd.edu/~fan/teach/262/notes/paul/10_5_notes.pdf</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Expectation Maximization</title>
      <link>https://JhuoW.github.io/posts/em-algo/</link>
      <pubDate>Fri, 01 Apr 2022 19:45:48 +0800</pubDate>
      
      <guid>https://JhuoW.github.io/posts/em-algo/</guid>
      <description>EM算法笔记</description>
      <content:encoded><![CDATA[<h1 id="最大似然估计mle">最大似然估计MLE</h1>
<p>数据 $X = \{x_1, \cdots x_N\}$, 模型参数为$\theta$，Likelihood 定义为 $P(X | \theta)$：当参数为$\theta$时，观测到给定数据$X$的概率。
$$
P(X|\theta) = L(\theta | X) = P_\theta(X) \tag{1}
$$
最大似然估计 （Maximum Likelihood Estimation, MLE）:
$$
\theta_{\mathrm{MLE}} = \arg \max_\theta  P(X|\theta)  \tag{2}
$$</p>
<blockquote>
<p>最大似然估计：给定一组样本$X$，模型的参数$\theta$是研究对象。若能找到参数$\theta_{\mathrm{MLE}}$，使得样本发生的可能性最大，则此估计值$\theta_{\mathrm{MLE}}$为参数$\theta$的最大似然估计。</p>
</blockquote>
<p>举例来说，如果模型是单个Gaussian Distribution下，参数为Gaussian Distribution的参数（均值$\mu$, 标准差$\Sigma$， $\theta = {\mu, \Sigma}$）.
给定一组数据$X$, 要计算$X$来自什么样的Gaussian，即：$P(\cdot | \theta) = f_\theta(\cdot) = \mathcal{N}(\cdot | \mu,\Sigma)$是一个Gaussian Distribution函数，目标为：
$$
\theta_{\mathrm{MLE}} = \mu^\star, \Sigma^\star = \arg \max_{\mu,\Sigma} \sum^N_{i = 1} \log \mathcal{N}(x_i|\mu,\Sigma)  \tag{3}
$$
即MLE的目标是找到最佳的高斯分布，是的从该分布中采样出数据$X$的概率最高。</p>
<p>如果只需要用一个Gaussian来拟合$X$的分布的话，这个Gaussian可以很容易用求导的方式获得$\theta_{\mathrm{MLE}}$的解析解：  对$\mu$求导：$\frac{\partial P(X|\mu,\Sigma)}{\partial \mu}$；对$\Sigma$求导：$\frac{\partial P(X|\mu,\Sigma)}{\partial \Sigma}$，令导数为0，即可求得最佳的$\mu$，$\Sigma$，使得对应的高斯分布符合数据$X = {x_1, \cdots x_N}$的分布。</p>
<p>但是，要用更复杂的模型（更多参数）来更准确的拟合$X$的分布，例如Gaussian Mixture Model，即多个Gaussian的组合，其模型参数为：
$$
\theta = \{\underbrace{\mu_1, \cdots,\mu_K}_{\text{每个Gaussian的 mean参数}}, \underbrace{\Sigma_1,\cdots, \Sigma_K}_{\text{每个Gaussian的 std参数}}, \underbrace{\alpha_1, \cdots, \alpha_{K-1}}_{\text{每个Gaussian的权重}} \}  \tag{4}
$$
假设是一个$K$个Gaussian的Gaussian Mixture Model，那么$\sum^K_{k = 1}\alpha_k = 1$。</p>
<p>给定数据$X = \{x_1, \cdots x_N\}$，若要用$K$维Gaussian Mixture Model来拟合该数据，就要优化所有$K$个Gaussian的均值参数，标准差参数，和权重参数，使得混合高斯分布采样出$X$的概率最大，即：
$$
\begin{aligned}
\theta_{\mathrm{MLE}} &amp;= \mu_1^\star,\cdots  \mu_K^\star,\Sigma_1^\star, \cdots, \Sigma_K^\star, \alpha^\star_1,\cdots,\alpha^\star_{K-1} \\
&amp;=\underset{\theta}{\arg\max} \sum^N_{i = 1} \log \sum^K_{k=1} \alpha_k \mathcal{N}(x_i|\mu_k,\Sigma_k)
\end{aligned} \tag{5}
$$
如果要得到上式的解析解，要对$\mu_1,\cdots,\mu_K, \Sigma_1, \cdots,\Sigma_K, \alpha_1, \cdots, \alpha_{K-1}$求导，再令导数为0来求解，这非常困难，由此引出EM算法。</p>
<h1 id="期望最大算法">期望最大算法</h1>
<p>求解MLE问题时，在最大化log-likelihood:
$$
\theta_{\mathrm{MLE}} = \arg \max_\theta \log  P(X|\theta)  \tag{6}
$$
难以直接对$\theta$求导来得到解析解时（如高斯混合模型情况），可以使用EM算法来迭代求解：
$$
\theta^{(t+1)}=\underset{\theta}{\arg \max} \int_z \log P(X,z | \theta) \cdot P(z|X,\theta^{(t)}) dz   \tag{7}
$$
$X$为观测数据， $z$为latent variables（隐变量），隐变量必须不会影响$X$的边缘分布,即 $P(X) = \int_z P(X|z) P(z) dz$。</p>
<p>而公式(7)中
$$
\begin{aligned}
&amp;\int_z \underbrace{\log P(X,z | \theta)}_{\text{每个z对应的值}} \cdot \underbrace{P(z|X,\theta^{(t)})}_{\text{z的分布}} dz\\
=&amp;\mathbb{E}_{P(z|X,\theta^{(t)})} \left[\log P(X,z | \theta)\right]
\end{aligned} \tag{8}
$$
所以，期望最大化算法求参数$\theta$的迭代公式可改写为:
$$
\theta^{(t+1)}=\arg \max_\theta \mathbb{E}_{P(z|X,\theta^{(t)})} \left[\log P(X,z | \theta)\right]     \quad \text{期望最大化}  \tag{9}
$$</p>
<p>其中$P(z|X,\theta^{(t)})$为后验分布posterior。</p>
<h1 id="em算法收敛性证明">EM算法收敛性证明</h1>
<p>因为EM算法通过迭代的方式优化模型参数$\theta$，使得对数似然$\log P(X|\theta)$最大。通过公式(7)，可以保证在$\theta^{(t+1)}$参数下的模型比$\theta^{(t)}$参数下的模型更拟合数据分布。通过公式(7)迭代更新参数$\theta^{(t)} \to \theta^{(t+1)}$，可以使得$\log P(X|\theta)$变大。收敛性即证明：
$$
\log P(X|\theta^{(t)}) \leq \log P(X|\theta^{(t+1)})  \tag{10}
$$
证明.
$$
\begin{aligned}
&amp;\because P(X,z) = P(z|X) P(X)\quad \text{always true}, \text{then}\quad P(X) = \frac{P(X,z)}{P(z|X)} \\
&amp;\therefore P(X|\theta) = \frac{P(X,z|\theta)}{P(z|X,\theta)} \\
&amp;\therefore \log P(X|\theta) = \log P(X,z|\theta) - \log P(z|X,\theta)
\end{aligned} \tag{11}
$$
上式左右两边对分布$P(z|X,\theta^{(t)})$求期望：
$$
\mathbb{E}_{z \sim P(z|X,\theta^{(t)})} \underbrace{\left[\log P(X|\theta)\right]}_{\text{与z无关}} = \mathbb{E}_{z \sim P(z|X,\theta^{(t)})} \left[\log P(X,z|\theta) - \log P(z|X,\theta)\right]  \tag{12}
$$
上式左边$=\log P(X|\theta)$，右边：
$$
\begin{aligned}
&amp;\mathbb{E}_{P(z|X,\theta^{(t)})} \left[\log P(X,z|\theta) - \log P(z|X,\theta)\right] \\
=&amp; \underbrace{\int_{z} P(z|X,\theta^{(t)}) \log P(X,z|\theta) dz}_{Q(\theta,\theta^{(t)})} - \underbrace{\int_z P(z|X,\theta^{(t)}) \log P(z|X,\theta) dz}_{H(\theta,\theta^{(t)})}
\end{aligned} \tag{13}
$$
注意到$Q(\theta,\theta^{(t)}) = \int_{z} P(z|X,\theta^{(t)}) \log P(X,z|\theta) dz$ 就是EM算法的迭代更新函数，即$\theta^{(t+1)} = \arg \max_\theta Q(\theta,\theta^{(t)})$。结合公式(12)和公式(13)：
$$
\log P(X|\theta) = Q(\theta,\theta^{(t)}) - H(\theta,\theta^{(t)}) \tag{14}
$$</p>
<blockquote>
<p>因此log-likelihood under $\theta^{(t)}$ and $\theta^{(t+1)}$：
$$
\begin{aligned}
\log P(X|\theta^{(t+1)}) &amp;= Q(\theta^{(t+1)},\theta^{(t)}) - H(\theta^{(t+1)},\theta^{(t)}) \\
\log P(X|\theta^{(t)}) &amp;= Q(\theta^{(t)},\theta^{(t)}) - H(\theta^{(t)},\theta^{(t)})
\end{aligned}  \tag{15}
$$</p>
</blockquote>
<p>首先，根据EM的迭代求解公式，$\theta^{(t+1)}$由
$$
\theta^{(t+1)} = \arg \max_\theta Q(\theta,\theta^{(t)})  \tag{16}
$$
得到，所以$Q(\theta^{(t+1)},\theta^{(t)}) \geq Q(\theta,\theta^{(t)})$一定成立。所以下式成立：
$$
Q(\theta^{(t+1)},\theta^{(t)}) \geq Q(\theta^{(t)},\theta^{(t)})  \tag{17}
$$
对于$H(\theta,\theta^{(t+1)})$，首先介绍<strong>Jensen Inequality</strong>:</p>
<blockquote>
<p>Jensen Inequality：</p>
<p>If $g(x)$ is a convex function on $R_X$, and $\mathbb{E}[g(x)]$ and $g(\mathbb{E}[X])$ are finite, then $\mathbb{E}[g(x)] \geq g(\mathbb{E}[X])$。</p>
<p><img loading="lazy" src="/posts/EM_Algo/Convex_b.png" alt=""  />
</p>
<p>显然$\log$是concave，所以$\mathbb{E}[\log(\cdot)]\leq \log(\mathbb{E}[\cdot])$。同理$-\log$是convex，所以$\mathbb{E}[-\log(\cdot)]\geq -\log(\mathbb{E}[\cdot])$。</p>
</blockquote>
<p>下面，计算$H(\theta^{(t)},\theta^{(t)})-H(\theta,\theta^{(t)})$：
$$
\begin{aligned}
&amp;H(\theta,\theta^{(t)}) = \int_z P(z|X,\theta^{(t)}) \log P(z|X,\theta) dz \\
&amp;H(\theta^{(t)},\theta^{(t)})-H(\theta,\theta^{(t)})\\
=&amp;\int_z P(z|X,\theta^{(t)}) \log P(z|X,\theta^{(t)}) dz - \int_z P(z|X,\theta^{(t)}) \log P(z|X,\theta) dz \\
=&amp; \underbrace{\int_z P(z|X,\theta^{(t)}) \log \frac{P(z|X,\theta^{(t)})}{P(z|X,\theta)} dz}_{\mathrm{KL}(P(z|X,\theta^{(t)})|P(z|X,\theta))}\\
=&amp; -\int_z P(z|X,\theta^{(t)}) \log \frac{P(z|X,\theta)}{P(z|X,\theta^{(t)})} dz \\
=&amp; \mathbb{E}_{P(z|X,\theta^{(t)})} \left[-\log \frac{P(z|X,\theta)}{P(z|X,\theta^{(t)})}\right]\\
\geq &amp; -\log \mathbb{E}_{P(z|X,\theta^{(t)})} \left[\frac{P(z|X,\theta)}{P(z|X,\theta^{(t)})}\right] \\
=&amp; -\log \int_z \frac{P(z|X,\theta)}{P(z|X,\theta^{(t)})} \cdot P(z|X,\theta^{(t)}) dz \\
=&amp; -\log \int_z P(z|X,\theta) dz \\
=&amp; - \log 1  \\
=&amp; 0
\end{aligned}\tag{18}
$$
因此，下式成立：
$$
\begin{aligned}
&amp;\therefore H(\theta^{(t)},\theta^{(t)})\geq H(\theta,\theta^{(t)})  \\
&amp;\therefore H(\theta^{(t+1)},\theta^{(t)}) \leq  H(\theta^{(t)},\theta^{(t)}) \\
&amp;\because  Q(\theta^{(t+1)},\theta^{(t)}) \geq Q(\theta^{(t)},\theta^{(t)})\\
&amp;\therefore Q(\theta^{(t+1)},\theta^{(t)}) - H(\theta^{(t+1)},\theta^{(t)}) \geq Q(\theta^{(t)},\theta^{(t)}) - H(\theta^{(t)},\theta^{(t)}) \\
&amp;\therefore \log P(X|\theta^{(t+1)}) \geq \log P(X|\theta^{(t)})
\end{aligned} \tag{19}
$$
所以通过EM算法的迭代得到新的$\theta^{(t+1)}$增大likelihood，使得模型更加拟合数据。</p>
<h1 id="em算法公式推导">EM算法公式推导</h1>
<p>EM算法Maximize Likelihood Estimation迭代公式：
$$
\begin{aligned}
\theta^{(t+1)}&amp;=\underset{\theta}{\arg \max} \int_z \log P(X,z | \theta) \cdot P(z|X,\theta^{(t)}) dz\\
&amp;=\arg \max_\theta \mathbb{E}_{P(z|X,\theta^{(t)})} \left[\log P(X,z | \theta)\right]<br>
\end{aligned} \tag{20}
$$</p>
<ul>
<li>E-Step： $\mathbb{E}_{P(z|X,\theta^{(t)})} \left[\log P(X,z | \theta)\right]$</li>
<li>M-Step：$\arg \max_\theta \mathbb{E}_{P(z|X,\theta^{(t)})} \left[\log P(X,z | \theta)\right]$</li>
</ul>
<p>其中，$X$是观测数据，$z$是隐变量，$(X,z)$为完整数据，$\theta$为待优化模型参数，$P(\cdot|X)$为后验。</p>
<p>上一节通过收敛性证明，验证了上式每次迭代都朝着最大化log-likelihood的方向。本节推导EM的迭代公式。</p>
<p>公式(11)中得到：
$$
\log P(X|\theta) = \log P(X,z|\theta) - \log P(z|X,\theta) \tag{21}
$$
引入一个关于隐变量$z$的分布$q(z)$，可以定义为任意关于$z$的非0分布。上式可以改写为：
$$
\log P(X|\theta) = \log \frac{P(X,z|\theta)}{q(z)} - \log\frac{ P(z|X,\theta)}{q(z)} \tag{22}
$$
左右两边对$q(z)$求期望：
$$
\text{左边} = \mathbb{E}_{q(z)} \log P(X|\theta) = \int_z q(z) \log P(X|\theta) dz = \log P(X|\theta)  \underbrace{\int_z q(z) dz}_{=1} =  \log P(X|\theta) \tag{23}
$$</p>
<p>$$
\begin{aligned}
\text{右边}&amp;=\mathbb{E}_{q(z)}  \left[\log \frac{P(X,z|\theta)}{q(z)} - \log\frac{ P(z|X,\theta)}{q(z)}\right]    \\
&amp;= \underbrace{\int_z q(z) \log \frac{P(X,z|\theta)}{q(z)} dz}_{ELBO=\text{Evidence Lower Bound}} \underbrace{- \int_z q(z)  \log\frac{ P(z|X,\theta)}{q(z)} dz}_{\mathrm{KL}(q(z)||P(z|X,\theta))}
\end{aligned} \tag{24}
$$</p>
<p>所以
$$
\log P(X|\theta) = ELBO + \mathrm{KL}(q(z)||P(z|X,\theta)) \tag{25}
$$
其中$P(z|X,\theta)$为后验（posterior）。而$\mathrm{KL}(q(z)||P(z|X,\theta)) \geq 0$, 当分布$q(z) = P(z|X,\theta)$时，等号成立。所以
$$
\log P(X|\theta) \geq ELBO = \int_z q(z) \log \frac{P(X,z|\theta)}{q(z)} dz \tag{26}
$$
因此，最大化log-likelihood $\log P(X|\theta)$问题可以转化为最大化$\log P(X|\theta)$的下界ELBO，即：
$$
\hat{\theta} = \arg \max_\theta \log P(X|\theta) \Longleftrightarrow \hat{\theta} =  \arg \max_\theta ELBO \tag{27}
$$</p>
<p>$$
\begin{aligned}
\hat{\theta} &amp;=  \arg \max_\theta ELBO \\
&amp; = \arg \max_\theta \int_z q(z) \log \frac{P(X,z|\theta)}{q(z)} dz  \quad \text{令关于}z\text{的分布}q(z) = P(z|X,\theta^{(t)})\\
&amp;= \arg \max_\theta \int_z P(z|X,\theta^{(t)}) \left[\log P(X,z|\theta) -  \underbrace{P(z|X,\theta^{(t)})}_{\text{与}\theta \text{无关，去掉不影响结果}}\right] dz \\
&amp;= \arg \max_\theta \int_z P(z|X,\theta^{(t)}) \log P(X,z|\theta) dz\\
&amp;= \text{公式(7)}
\end{aligned} \tag{28}
$$</p>
<p>我把本文整理成了<a href="/posts/EM_Algo/EM.pdf">PDF</a></p>
<h1 id="参考">参考</h1>
<p><a href="https://youtube.com/playlist?list=PLOxMGJ_8X74bhcPbpiX642NIfPlkpD1BC">https://youtube.com/playlist?list=PLOxMGJ_8X74bhcPbpiX642NIfPlkpD1BC</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/78311644">https://zhuanlan.zhihu.com/p/78311644</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Blog, Tools and Survey</title>
      <link>https://JhuoW.github.io/posts/2019-04-28-paper-unscramble/</link>
      <pubDate>Tue, 29 Mar 2022 11:03:50 +0000</pubDate>
      
      <guid>https://JhuoW.github.io/posts/2019-04-28-paper-unscramble/</guid>
      <description>这篇笔记用于收藏别人的博客
Tech Blog    Blog Author     https://michael-bronstein.medium.com/ Michael Bronstein   https://geometricdeeplearning.com/ Michael Bronstein   https://www.notion.so/Paper-Notes-by-Vitaly-Kurin-97827e14e5cd4183815cfe3a5ecf2f4c Vitaly Kurin (Many Paper Notes)   https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial1/Lisa_Cluster.html UvA DL Notebooks   https://graph-neural-networks.github.io/index.html GNN Books   http://prob140.org/sp17/textbook/ Probability for Data Science class at UC Berkeley   https://graphreason.github.io/schedule.html Learning and Reasoning with Graph-Structured Representations ICML 2019 Workshop   https://chuxuzhang.github.io/KDD21_Tutorial.html KDD2021 Tutorial: Data Efficient Learning on Graphs   http://songcy.</description>
      <content:encoded><![CDATA[<p><strong>这篇笔记用于收藏别人的博客</strong></p>
<h1 id="tech-blog">Tech Blog</h1>
<table>
<thead>
<tr>
<th>Blog</th>
<th>Author</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://michael-bronstein.medium.com/">https://michael-bronstein.medium.com/</a></strong></td>
<td>Michael Bronstein</td>
</tr>
<tr>
<td><strong><a href="https://geometricdeeplearning.com/">https://geometricdeeplearning.com/</a></strong></td>
<td>Michael Bronstein</td>
</tr>
<tr>
<td><strong><a href="https://www.notion.so/Paper-Notes-by-Vitaly-Kurin-97827e14e5cd4183815cfe3a5ecf2f4c">https://www.notion.so/Paper-Notes-by-Vitaly-Kurin-97827e14e5cd4183815cfe3a5ecf2f4c</a></strong></td>
<td>Vitaly Kurin (Many Paper Notes)</td>
</tr>
<tr>
<td><strong><a href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial1/Lisa_Cluster.html">https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial1/Lisa_Cluster.html</a></strong></td>
<td>UvA DL Notebooks</td>
</tr>
<tr>
<td><strong><a href="https://graph-neural-networks.github.io/index.html">https://graph-neural-networks.github.io/index.html</a></strong></td>
<td>GNN Books</td>
</tr>
<tr>
<td><strong><a href="http://prob140.org/sp17/textbook/">http://prob140.org/sp17/textbook/</a></strong></td>
<td><a href="http://prob140.org/">Probability for Data Science</a> class at UC Berkeley</td>
</tr>
<tr>
<td><strong><a href="https://graphreason.github.io/schedule.html">https://graphreason.github.io/schedule.html</a></strong></td>
<td><a href="https://graphreason.github.io/index.html">Learning and Reasoning with Graph-Structured Representations</a> ICML 2019 Workshop</td>
</tr>
<tr>
<td><strong><a href="https://chuxuzhang.github.io/KDD21_Tutorial.html">https://chuxuzhang.github.io/KDD21_Tutorial.html</a></strong></td>
<td>KDD2021 Tutorial: Data Efficient Learning on Graphs</td>
</tr>
<tr>
<td><strong><a href="http://songcy.net/posts/">http://songcy.net/posts/</a></strong></td>
<td>Changyue Song (Kernel)</td>
</tr>
<tr>
<td><strong><a href="https://www.cs.mcgill.ca/~wlh/grl_book/">https://www.cs.mcgill.ca/~wlh/grl_book/</a></strong></td>
<td>William L. Hamilton</td>
</tr>
<tr>
<td><strong><a href="https://kexue.fm/">https://kexue.fm/</a></strong></td>
<td>BoJone</td>
</tr>
<tr>
<td><strong><a href="https://danielegrattarola.github.io/blog/">https://danielegrattarola.github.io/blog/</a></strong></td>
<td>Daniele Grattarola (EPFL)</td>
</tr>
<tr>
<td><strong><a href="https://ai.googleblog.com/2022/03/robust-graph-neural-networks.html">https://ai.googleblog.com/2022/03/robust-graph-neural-networks.html</a></strong></td>
<td>Google AI Blog</td>
</tr>
<tr>
<td><strong><a href="https://zhiyuchen.com/blogs/">https://zhiyuchen.com/blogs/</a></strong></td>
<td>Zhiyu Chen</td>
</tr>
<tr>
<td><strong><a href="https://andreasloukas.blog/">https://andreasloukas.blog/</a></strong></td>
<td>Andreas Loukas (EPFL)</td>
</tr>
<tr>
<td><strong><a href="https://irhum.pubpub.org/pub/gnn/release/4">https://irhum.pubpub.org/pub/gnn/release/4</a></strong></td>
<td>Understanding Graph Neural Networks</td>
</tr>
<tr>
<td><strong><a href="https://lilianweng.github.io/">https://lilianweng.github.io/</a></strong></td>
<td>Lilian Weng</td>
</tr>
<tr>
<td><strong><a href="https://www.zhihu.com/column/marlin">https://www.zhihu.com/column/marlin</a></strong></td>
<td>深度学习与图网络</td>
</tr>
<tr>
<td><strong><a href="https://github.com/roboticcam/machine-learning-notes">https://github.com/roboticcam/machine-learning-notes</a></strong></td>
<td>Yida Xu</td>
</tr>
<tr>
<td><strong><a href="https://www.dgl.ai/pages/index.html">https://www.dgl.ai/pages/index.html</a></strong></td>
<td>DGL</td>
</tr>
<tr>
<td><strong><a href="https://www.kexinhuang.com/tech-blog">https://www.kexinhuang.com/tech-blog</a></strong></td>
<td>Kexin Huang</td>
</tr>
<tr>
<td><strong><a href="https://rish16.notion.site/a8c6fcb0c29c4764afa1926ad33084f8?v=bb27bb0444574fbd85f0c9d7e43b9da8">https://rish16.notion.site/a8c6fcb0c29c4764afa1926ad33084f8?v=bb27bb0444574fbd85f0c9d7e43b9da8</a></strong></td>
<td>Rishabh Anand</td>
</tr>
<tr>
<td><strong><a href="https://saashanair.com/blog">https://saashanair.com/blog</a></strong></td>
<td>Saasha Nair</td>
</tr>
<tr>
<td><strong><a href="http://www.huaxiaozhuan.com/">http://www.huaxiaozhuan.com/</a></strong></td>
<td>华校专</td>
</tr>
<tr>
<td><strong><a href="https://github.com/dglai/WWW20-Hands-on-Tutorial">https://github.com/dglai/WWW20-Hands-on-Tutorial</a></strong></td>
<td>DGL</td>
</tr>
<tr>
<td><strong><a href="https://blog.csdn.net/CSDNTianJi/article/details/104195306">https://blog.csdn.net/CSDNTianJi/article/details/104195306</a></strong></td>
<td>Meng Liu</td>
</tr>
<tr>
<td><strong><a href="https://www.chaitjo.com/post/">https://www.chaitjo.com/post/</a></strong></td>
<td>Chaitanya K. Joshi</td>
</tr>
<tr>
<td><strong><a href="https://scottfreitas.medium.com/">https://scottfreitas.medium.com/</a></strong></td>
<td>Scott Freitas</td>
</tr>
<tr>
<td><strong><a href="https://fabianfuchsml.github.io/">https://fabianfuchsml.github.io/</a></strong></td>
<td>Fabian Fuchs</td>
</tr>
<tr>
<td><strong><a href="https://medium.com/@pantelis.elinas">https://medium.com/@pantelis.elinas</a></strong></td>
<td>Pantelis Elinas</td>
</tr>
<tr>
<td><a href="https://github.com/tianyicui/pack">https://github.com/tianyicui/pack</a></td>
<td>背包9講</td>
</tr>
<tr>
<td><a href="https://www.fenghz.xyz/">https://www.fenghz.xyz/</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://sakigami-yang.me/2017/08/13/about-kernel-01/">https://sakigami-yang.me/2017/08/13/about-kernel-01/</a></td>
<td>kernel</td>
</tr>
<tr>
<td><a href="https://davidham3.github.io/blog">https://davidham3.github.io/blog</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://fenghz.github.io/index.html">https://fenghz.github.io/index.html</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://archwalker.github.io/">https://archwalker.github.io/</a></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="awesome-awesomes">Awesome-Awesomes</h1>
<table>
<thead>
<tr>
<th>Repo</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://github.com/naganandy/graph-based-deep-learning-literature">https://github.com/naganandy/graph-based-deep-learning-literature</a></strong></td>
<td><strong>links to conference publications in graph-based deep learning</strong> (Very, Very, Very Important)</td>
</tr>
<tr>
<td><a href="https://github.com/SherylHYX/pytorch_geometric_signed_directed">https://github.com/SherylHYX/pytorch_geometric_signed_directed</a></td>
<td>PyTorch Geometric Signed Directed is a signed/directed graph neural network extension library for PyTorch Geometric.</td>
</tr>
<tr>
<td><a href="https://github.com/EdisonLeeeee/Awesome-Fair-Graph-Learning">https://github.com/EdisonLeeeee/Awesome-Fair-Graph-Learning</a></td>
<td>Paper Lists for Fair Graph Learning</td>
</tr>
<tr>
<td><a href="https://github.com/thunlp/PromptPapers">https://github.com/thunlp/PromptPapers</a></td>
<td>Must-read papers on prompt-based tuning for pre-trained language models.</td>
</tr>
<tr>
<td><a href="https://github.com/zhao-tong/graph-data-augmentation-papers">https://github.com/zhao-tong/graph-data-augmentation-papers</a></td>
<td>A curated list of graph data augmentation papers.</td>
</tr>
<tr>
<td><a href="https://github.com/Thinklab-SJTU/ThinkMatch">https://github.com/Thinklab-SJTU/ThinkMatch</a></td>
<td>Code &amp; pretrained models of novel deep graph matching methods.</td>
</tr>
<tr>
<td><a href="https://github.com/FLHonker/Awesome-Knowledge-Distillation">https://github.com/FLHonker/Awesome-Knowledge-Distillation</a></td>
<td>Awesome Knowledge-Distillation. 分类整理的知识蒸馏paper(2014-2021)。</td>
</tr>
<tr>
<td><a href="https://github.com/zlpure/awesome-graph-representation-learning">https://github.com/zlpure/awesome-graph-representation-learning</a></td>
<td>A curated list for awesome graph representation learning resources.</td>
</tr>
<tr>
<td><a href="https://github.com/basiralab/GNNs-in-Network-Neuroscience">https://github.com/basiralab/GNNs-in-Network-Neuroscience</a></td>
<td>A review of papers proposing novel GNN methods with application to brain connectivity published in 2017-2020.</td>
</tr>
<tr>
<td><a href="https://github.com/flyingdoog/awesome-graph-explainability-papers">https://github.com/flyingdoog/awesome-graph-explainability-papers</a></td>
<td>Papers about explainability of GNNs</td>
</tr>
<tr>
<td><a href="https://github.com/yuanqidu/awesome-graph-generation">https://github.com/yuanqidu/awesome-graph-generation</a></td>
<td>A curated list of graph generation papers and resources.</td>
</tr>
<tr>
<td><a href="https://github.com/benedekrozemberczki/awesome-decision-tree-papers">https://github.com/benedekrozemberczki/awesome-decision-tree-papers</a></td>
<td>A collection of research papers on decision, classification and regression trees with implementations.</td>
</tr>
<tr>
<td><a href="https://github.com/AstraZeneca/awesome-explainable-graph-reasoning">https://github.com/AstraZeneca/awesome-explainable-graph-reasoning</a></td>
<td>A collection of research papers and software related to explainability in graph machine learning.</td>
</tr>
<tr>
<td><a href="https://github.com/LirongWu/awesome-graph-self-supervised-learning">https://github.com/LirongWu/awesome-graph-self-supervised-learning</a></td>
<td>Awesome Graph Self-Supervised Learning</td>
</tr>
<tr>
<td><a href="https://github.com/Chen-Cai-OSU/awesome-equivariant-network">https://github.com/Chen-Cai-OSU/awesome-equivariant-network</a></td>
<td>Paper list for equivariant neural network</td>
</tr>
<tr>
<td><a href="https://github.com/mengliu1998/DL4DisassortativeGraphs">https://github.com/mengliu1998/DL4DisassortativeGraphs</a></td>
<td>Papers about developing DL methods on disassortative graphs</td>
</tr>
<tr>
<td><a href="https://github.com/SunQingYun1996/Graph-Reinforcement-Learning-Papers">https://github.com/SunQingYun1996/Graph-Reinforcement-Learning-Papers</a></td>
<td>A curated list of graph reinforcement learning papers.</td>
</tr>
<tr>
<td><a href="https://github.com/ChandlerBang/awesome-self-supervised-gnn">https://github.com/ChandlerBang/awesome-self-supervised-gnn</a></td>
<td>Papers about pretraining and self-supervised learning on Graph Neural Networks (GNN).</td>
</tr>
<tr>
<td><a href="https://github.com/GRAND-Lab/Awesome-Graph-Neural-Networks">https://github.com/GRAND-Lab/Awesome-Graph-Neural-Networks</a></td>
<td>Paper Lists for Graph Neural Networks</td>
</tr>
<tr>
<td><a href="https://github.com/jwzhanggy/IFMLab_GNN">https://github.com/jwzhanggy/IFMLab_GNN</a></td>
<td>Graph Neural Network Models from IFM Lab</td>
</tr>
<tr>
<td><a href="https://github.com/ChandlerBang/awesome-graph-attack-papers">https://github.com/ChandlerBang/awesome-graph-attack-papers</a></td>
<td>Adversarial attacks and defenses on Graph Neural Networks.</td>
</tr>
<tr>
<td><a href="https://github.com/safe-graph/graph-adversarial-learning-literature">https://github.com/safe-graph/graph-adversarial-learning-literature</a></td>
<td>A curated list of adversarial attacks and defenses papers on graph-structured data.</td>
</tr>
<tr>
<td><a href="https://github.com/benedekrozemberczki/awesome-graph-classification">https://github.com/benedekrozemberczki/awesome-graph-classification</a></td>
<td>A collection of important graph embedding, classification and representation learning papers with implementations.</td>
</tr>
<tr>
<td><a href="https://github.com/benedekrozemberczki/awesome-gradient-boosting-papers">https://github.com/benedekrozemberczki/awesome-gradient-boosting-papers</a></td>
<td>A curated list of gradient boosting research papers with implementations.</td>
</tr>
<tr>
<td><a href="https://github.com/benedekrozemberczki/awesome-community-detection">https://github.com/benedekrozemberczki/awesome-community-detection</a></td>
<td>A curated list of community detection research papers with implementations.</td>
</tr>
<tr>
<td><a href="https://github.com/giannifranchi/awesome-uncertainty-deeplearning">https://github.com/giannifranchi/awesome-uncertainty-deeplearning</a></td>
<td>This repository contains a collection of surveys, datasets, papers, and codes, for predictive uncertainty estimation in deep learning models.</td>
</tr>
<tr>
<td><a href="https://sites.google.com/site/graphmatchingmethods/">https://sites.google.com/site/graphmatchingmethods/</a></td>
<td>Efficient Methods for Graph Matching and MAP Inference</td>
</tr>
<tr>
<td><a href="https://github.com/yueliu1999/Awesome-Deep-Graph-Clustering">https://github.com/yueliu1999/Awesome-Deep-Graph-Clustering</a></td>
<td>Awesome Deep Graph Clustering is a collection of SOTA, novel deep graph clustering methods (papers, codes, and datasets).</td>
</tr>
<tr>
<td><a href="https://github.com/jwwthu/GNN4Traffic">https://github.com/jwwthu/GNN4Traffic</a></td>
<td>This is the repository for the collection of Graph Neural Network for Traffic Forecasting.</td>
</tr>
<tr>
<td><a href="https://github.com/zwt233/Awesome-Auto-GNNs">https://github.com/zwt233/Awesome-Auto-GNNs</a></td>
<td>A paper collection about automated graph learning</td>
</tr>
<tr>
<td><a href="https://github.com/chaitjo/awesome-efficient-gnn">https://github.com/chaitjo/awesome-efficient-gnn</a></td>
<td>Efficient Graph Neural Networks - a curated list of papers and projects</td>
</tr>
<tr>
<td><a href="https://github.com/Radical3-HeZhang/Awesome-Trustworthy-GNNs">https://github.com/Radical3-HeZhang/Awesome-Trustworthy-GNNs</a></td>
<td>Awesome Resources on Trustworthy Graph Neural Networks</td>
</tr>
<tr>
<td><a href="https://github.com/EdisonLeeeee/Awesome-Masked-Autoencoders">https://github.com/EdisonLeeeee/Awesome-Masked-Autoencoders</a></td>
<td>A collection of literature after or concurrent with Masked Autoencoder (MAE) (Kaiming He el al.).</td>
</tr>
</tbody>
</table>
<h1 id="useful-repotools">Useful Repo/Tools</h1>
<table>
<thead>
<tr>
<th>Name</th>
<th>Info</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://acronymify.com/">http://acronymify.com/</a></td>
<td>Model Name</td>
</tr>
<tr>
<td><a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></td>
<td>Graph Editor</td>
</tr>
<tr>
<td><strong><a href="https://github.com/guanyingc/python_plot_utils">https://github.com/guanyingc/python_plot_utils</a></strong></td>
<td>A simple code for plotting figure, colorbar, and cropping with python</td>
</tr>
<tr>
<td><strong><a href="https://github.com/guanyingc/latex_paper_writing_tips">https://github.com/guanyingc/latex_paper_writing_tips</a></strong></td>
<td>Tips for Writing a Research Paper using LaTeX</td>
</tr>
<tr>
<td><a href="https://github.com/JhuoW/Pytorch_Program_Templete">https://github.com/JhuoW/Pytorch_Program_Templete</a></td>
<td>Pytorch Program Templete GNN</td>
</tr>
<tr>
<td><a href="https://github.com/graph4ai/graph4nlp">https://github.com/graph4ai/graph4nlp</a></td>
<td>Graph4nlp is the library for the easy use of Graph Neural Networks for NLP. Welcome to visit our DLG4NLP website (<a href="https://dlg4nlp.github.io/index.html">https://dlg4nlp.github.io/index.html</a>) for various learning resources!</td>
</tr>
<tr>
<td><a href="https://github.com/benedekrozemberczki/pytorch_geometric_temporal">https://github.com/benedekrozemberczki/pytorch_geometric_temporal</a></td>
<td>PyTorch Geometric Temporal: Spatiotemporal Signal Processing with Neural Machine Learning Models (CIKM 2021)</td>
</tr>
<tr>
<td><a href="https://github.com/ysig/GraKeL">https://github.com/ysig/GraKeL</a></td>
<td>A scikit-learn compatible library for graph kernels</td>
</tr>
<tr>
<td><a href="https://github.com/jajupmochi/graphkit-learn">https://github.com/jajupmochi/graphkit-learn</a></td>
<td>A python package for graph kernels, graph edit distances, and graph pre-image problem.</td>
</tr>
<tr>
<td><a href="https://github.com/pliang279/awesome-phd-advice">https://github.com/pliang279/awesome-phd-advice</a></td>
<td>Collection of advice for prospective and current PhD students</td>
</tr>
<tr>
<td><a href="https://github.com/MLEveryday/100-Days-Of-ML-Code">https://github.com/MLEveryday/100-Days-Of-ML-Code</a></td>
<td>100-Days-Of-ML-Code中文版</td>
</tr>
<tr>
<td><a href="https://github.com/d2l-ai/d2l-zh">https://github.com/d2l-ai/d2l-zh</a></td>
<td>《动手学深度学习》</td>
</tr>
<tr>
<td><a href="https://github.com/lukas-blecher/LaTeX-OCR">https://github.com/lukas-blecher/LaTeX-OCR</a></td>
<td>pix2tex: Using a ViT to convert images of equations into LaTeX code.</td>
</tr>
<tr>
<td><a href="https://github.com/thunlp/OpenPrompt">https://github.com/thunlp/OpenPrompt</a></td>
<td>An Open-Source Framework for Prompt-Learning.</td>
</tr>
<tr>
<td><a href="https://github.com/snap-stanford/GraphGym">https://github.com/snap-stanford/GraphGym</a></td>
<td>Platform for designing and evaluating Graph Neural Networks (GNN)</td>
</tr>
<tr>
<td><a href="https://github.com/pygod-team/pygod">https://github.com/pygod-team/pygod</a></td>
<td>A Python Library for Graph Outlier Detection (Anomaly Detection)</td>
</tr>
<tr>
<td><a href="https://github.com/MLNLP-World/Paper_Writing_Tips">https://github.com/MLNLP-World/Paper_Writing_Tips</a></td>
<td>latex写作建议</td>
</tr>
<tr>
<td><a href="https://github.com/dair-ai/ML-YouTube-Courses">https://github.com/dair-ai/ML-YouTube-Courses</a></td>
<td>A place to discover the latest machine learning courses on YouTube.</td>
</tr>
</tbody>
</table>
<h1 id="miscellaneous">Miscellaneous</h1>
<table>
<thead>
<tr>
<th>Name</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/The-Run-Philosophy-Organization/run">https://github.com/The-Run-Philosophy-Organization/run</a></td>
<td>run学指南</td>
</tr>
<tr>
<td><a href="https://10beasts.net/">https://10beasts.net/</a></td>
<td>测评</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Maximum Mean Discrepancy</title>
      <link>https://JhuoW.github.io/posts/mmd/</link>
      <pubDate>Sun, 27 Mar 2022 10:45:08 +0800</pubDate>
      
      <guid>https://JhuoW.github.io/posts/mmd/</guid>
      <description>Mean Discrepancy (MD)均值差异 判断2个分布$p$ 和$q$是否相同。
$p$分布生成一个样本空间$\mathbb{P}$ (从$p$中采样$m$个样本)
$q$分布生成一个样本空间$\mathbb{Q}$（从$q$中采样$n$个样本）
函数$f$的输入为 分布生成的样本空间
如果 $$ \begin{equation} \begin{aligned} \mathrm{mean}(f(\mathbb{P})) == \mathrm{mean}(f(\mathbb{Q})) \\ i.e., \frac{1}{m}\sum^m_{i=1}f(p_i) = \frac{1}{n}\sum^n_{i=1}f(q_i) \end{aligned} \end{equation} $$
则$p$和$q$是同一分布。
MD can be defined as $$ \begin{equation} \begin{aligned} \mathrm{MD}&amp;amp;=|\mathrm{mean}(f(\mathbb{P})) -\mathrm{mean}(f(\mathbb{Q})) | \\ &amp;amp;= |\frac{1}{m}\sum^m_{i=1}f(p_i) - \frac{1}{n}\sum^n_{i=1}f(q_i)| \end{aligned} \end{equation} $$
Maximum Mean Discrepancy (MMD) 最大均值差异 定义 MMD: 在函数集$\mathcal{F}=\{f_1, f_2, \cdots \}$中， 找到一个函数$f^*$， 使得$|\mathrm{mean}(f^*(\mathbb{P})) -\mathrm{mean}(f^*(\mathbb{Q})) |$ 最大。 这个最大值就是两个分布之间的最大均值差异（MMD）。MMD =0 表示两个分布相同。 $$ \operatorname{MMD}[\mathcal{F}, p, q]:=\sup _{f \in \mathcal{F}}\left(\mathbf{E}_{x \sim p}[f(x)]-\mathbf{E}_{y \sim q}[f(y)]\right) $$ 其中$\mathbf{E}_{x \sim p}[f(x)]$表示分布$p$在函数$f$下的均值， $\sup$为上确界直接理解为max就好。</description>
      <content:encoded><![CDATA[<h1 id="mean-discrepancy-md均值差异">Mean Discrepancy (MD)均值差异</h1>
<p>判断2个分布$p$ 和$q$是否相同。</p>
<p>$p$分布生成一个样本空间$\mathbb{P}$ (从$p$中采样$m$个样本)</p>
<p>$q$分布生成一个样本空间$\mathbb{Q}$（从$q$中采样$n$个样本）</p>
<p>函数$f$的输入为 分布生成的样本空间</p>
<p>如果
$$
\begin{equation}
\begin{aligned}
\mathrm{mean}(f(\mathbb{P})) == \mathrm{mean}(f(\mathbb{Q})) \\
i.e., \frac{1}{m}\sum^m_{i=1}f(p_i) = \frac{1}{n}\sum^n_{i=1}f(q_i)
\end{aligned}
\end{equation}
$$</p>
<p>则$p$和$q$是同一分布。</p>
<p><strong>MD</strong> can be defined as
$$
\begin{equation}
\begin{aligned}
\mathrm{MD}&amp;=|\mathrm{mean}(f(\mathbb{P})) -\mathrm{mean}(f(\mathbb{Q})) | \\
&amp;= |\frac{1}{m}\sum^m_{i=1}f(p_i) - \frac{1}{n}\sum^n_{i=1}f(q_i)|
\end{aligned}
\end{equation}
$$</p>
<h1 id="maximum-mean-discrepancy-mmd-最大均值差异">Maximum Mean Discrepancy (MMD) 最大均值差异</h1>
<h2 id="定义">定义</h2>
<p><strong>MMD:</strong>  在函数集$\mathcal{F}=\{f_1, f_2, \cdots \}$中， 找到一个函数$f^*$， 使得$|\mathrm{mean}(f^*(\mathbb{P})) -\mathrm{mean}(f^*(\mathbb{Q})) |$ 最大。 这个最大值就是两个分布之间的<strong>最大均值差异</strong>（MMD）。MMD =0 表示两个分布相同。
$$
\operatorname{MMD}[\mathcal{F}, p, q]:=\sup _{f \in \mathcal{F}}\left(\mathbf{E}_{x \sim p}[f(x)]-\mathbf{E}_{y \sim q}[f(y)]\right)
$$
其中$\mathbf{E}_{x \sim p}[f(x)]$表示分布$p$在函数$f$下的均值， $\sup$为上确界直接理解为max就好。</p>
<h2 id="条件">条件</h2>
<p>为了准确判断分布$p$和$q$之间的距离，需要找到一个合适的函数，使得两个分布在这个函数上的距离尽可能大，但搜索空间不能过于大，所以函数空间$\mathcal{F}$要满足两个条件：</p>
<p><strong>C1:</strong> 函数集$\mathcal{F}$要足够丰富， 使得MMD尽可能准确</p>
<p><strong>C2:</strong> 考虑数据集样本数量，随着数据集的增大，MMD要能迅速收敛，要求$\mathcal{F}$足够restrictive (函数集不能无限大)</p>
<p>所以利用<a href="https://jhuow.github.io/posts/rkhs_kernel/">kernel</a> 方法，即， 将两个分布的样本空间映射到一个高维或者无限维的空间$\mathcal{H}$中，如果两个分布的样本在$\mathcal{H}$中的均值依然相等，那么这两个分布相等，MMD=0。两个分布在$\mathcal{H}$中的最大均值为MMD。</p>
<p><strong>因此，当$\mathcal{F}$是再生核Hilbert Space 上的单位球（unit ball）时，可以满足以上两个条件</strong>。 即，将$\mathcal{F}$定义为某个kernel对应的RKHS中的函数， 例如，</p>
<p>给定一个Gaussian Kernel: $k(u,v) = \{\exp({-\frac{||u-v||^2}{2\sigma}})\}_\sigma$, 这个kernel函数是一个Hilbert Space的再生核，那么这个空间可以表示为</p>
<p>$$
\begin{equation}
\mathcal{H}_k = \operatorname{span}({\Phi(x): x \in \mathcal{X}})=\left\{f(\cdot)=\sum_{i=1}^{m} \alpha_{i} k\left(\cdot, x_{i}\right): m \in \mathbf{N}, x_{i} \in \mathcal{X}, \alpha_{i} \in \mathbf{R}\right\} \tag{1}
\end{equation}
$$
空间$\mathcal{X}$中的每个元素$x_i$都对应于一个函数$k(\cdot,x_i)=k_{x_i}(\cdot)$, 那么$\mathcal{X}$中的所有元素所产生的函数$\{k_{x_i}(\cdot)\}_{x_i \in \mathcal{X}}$ 可以span成一个<strong>Function Space</strong>, 如公式1所示， 这个function space中的每个function可以由&quot;basis functions&quot;$\{k_{x_i}(\cdot)\}_{x_i \in \mathcal{X}}$ 通过线性组合得到。那么</p>
<p>$$f(\cdot)=\sum_{i=1}^{m} \alpha_{i} k\left(\cdot, x_{i}\right)$$</p>
<p>可以表示kernel $k(\cdot, \cdot)$的RKHS中的每个function。 每个valid kernel都有一个RKHS $\mathcal{H}_k$与它对应。</p>
<p>我们将MMD的候选函数集$\mathcal{F}$定义为某一个kernel $k(\cdot,\cdot)$所对应的RKHS $\mathcal{H}_k$中的函数，这样就可以满足所有候选函数都在$\mathcal{H}_k$中(足够多)，同时如果kernel是Gaussian Kernel, 相当于把样本空间映射到无限高维来做MD,更加准确。</p>
<p>另外，我们限制范式norm$||f||_{\mathcal{H}_k} \leq 1$来避免上界取到无限大</p>
<h2 id="回到mmd">回到MMD</h2>
<p>已知$\mathcal{F}=\{f_1(\cdot), f_2(\cdot), \cdots \}$中的每个函数都是一个高斯核函数$k(\cdot,\cdot)$的RKHS中的函数，要从$\mathcal{H}_k$中选一个函数$f^*(\cdot)$，使得两个分布的样本间距离在$k(\cdot,\cdot)$的RKHS上最大。</p>
<p>因为$f(\cdot)$是$\mathcal{H}_k$中的一个函数，那么$f(\cdot)$可以表示为$\sum_{i=1}^{m} \alpha_{i} k\left(\cdot, x_{i}\right)$, 此时，下式一定成立（参考<a href="https://jhuow.github.io/posts/rkhs_kernel/">这里</a>）：</p>
<p>$$
f(x) = \langle f(\cdot), k(\cdot, x) \rangle_{\mathcal{H}_k}
$$
$k(\cdot, x) = \Phi(x)$表示将$x$映射到空间$\mathcal{H}_{k}$上的值，即$x$在$\mathcal{H}_{k}$上的表示。 若$k$是Gaussian Kernel, 那么$k(\cdot, x)$就是$x$在无限维空间上的表示。</p>
<p>连续空间中$\mathbf{E}_{x \sim p}[f(x)]$可以写为：
$$
\begin{equation}
\begin{aligned}
\mathbf{E}_{x \sim p}[f(x)] &amp;= \int_x p(x)f(x) dx\\
&amp; = \int_x p(x) \langle f(\cdot), k(\cdot, x) \rangle_{\mathcal{H}_k} dx \\
&amp;= \langle \int_x p(x)f(\cdot) dx, \int_x p(x)k(\cdot, x) dx \rangle_{\mathcal{H}_k}\\
&amp;= \langle f(\cdot), \mu_p\rangle_{\mathcal{H}_k}
\end{aligned}
\end{equation}
$$
其中$\mu_p = \int_x p(x)k(\cdot, x) dx$.</p>
<p>因此，MMD可以改写为：
$$
\begin{equation}
\begin{aligned}
\operatorname{MMD}(\mathrm{p}, \mathrm{q}, \mathcal{H})&amp;:=\sup_{f \in \mathcal{H},|f|_{\mathcal{H}} \leq 1}(\underset{\mathrm{p}(\boldsymbol{x})}{\mathbb{E}}[f(\boldsymbol{x})]-\underset{\mathrm{q}(\boldsymbol{y})}{\mathbb{E}}[f(\boldsymbol{y})])\\
&amp;=\sup_{f \in \mathcal{H},|f|_{\mathcal{H}_k} \leq 1}\left(\left\langle\mu_{\mathrm{p}}-\mu_{\mathrm{q}}, f\right\rangle_{\mathcal{H}_k}\right)
\end{aligned}
\end{equation}
$$
利用内积性质：$\langle a, b \rangle \leq ||a|| ||b||$， 因为
$$
||f(\cdot)||_{\mathcal{H}_k}\leq 1
$$
,
$$
\left\langle\mu_{\mathrm{p}}-\mu_{\mathrm{q}}, f\right\rangle_{\mathcal{H}_k} \leq ||\mu_{\mathrm{p}}-\mu_{\mathrm{q}}||_{\mathcal{H}_k}||f||_{\mathcal{H}_k}
$$
Then,
$$
\sup_{f \in \mathcal{H},|f|_{\mathcal{H}_k} \leq 1}\left(\left\langle\mu_{\mathrm{p}}-\mu_{\mathrm{q}}, f\right\rangle_{\mathcal{H}_k}\right) =||\mu_{\mathrm{p}}-\mu_{\mathrm{q}}||_{\mathcal{H}_k}
$$
其中$\mu_p = \int_x p(x)k(\cdot, x) dx$, $\mu_q = \int_y q(y)k(\cdot, y) dy$ 分别表示分布的期望(均值)。 然而期望无法直接计算，因此用样本空间的均值代替分布的期望：
$$
\begin{equation}
\begin{aligned}
\mathrm{M M D}(p,q,\mathcal{H}_k) &amp; \approx \mathrm{M M D}(X,Y,\mathcal{F}_{\mathcal{H}_k})\\ &amp;=\left|\left|\frac{1}{n} \sum_{i=1}^{n} f(x_i)-\frac{1}{m} \sum_{j=1}^{m} f(x_j)\right|\right|_{\mathcal{H}_k}
\end{aligned}
\end{equation}
$$</p>
<p>$$
\begin{equation}
\begin{aligned}
\mathrm{M M D}^2(p,q,\mathcal{H}_k) &amp; \approx \mathrm{M M D}^2(X,Y,\mathcal{F}_{\mathcal{H}_k})\\
&amp;=\left|\left|\frac{1}{n} \sum_{i=1}^{n} f(x_i)-\frac{1}{m} \sum_{j=1}^{m} f(x_j)\right|\right|_{\mathcal{H}_k}^{2}\\
&amp;= \left|\left|\frac{1}{n^{2}} \sum_{i}^{n} \sum_{i^{\prime}}^{n} \left\langle f(x_i),f(x_i^{\prime})\right\rangle-\frac{2}{n m} \sum_{i}^{n} \sum_{j}^{m} \left\langle f(x_i), f(y_j)\right\rangle+\frac{1}{m^{2}} \sum_{j}^{m} \sum_{j^{\prime}}^{m} \left\langle f(y_j), f(y_j^{\prime})\right\rangle\right|\right|_{\mathcal{H}_k} \\
&amp; = \frac{1}{n^2} K_{x, x^\prime}-\frac{2}{nm} K_{x, y}+\frac{1}{m^{2}} K_{y, y^{\prime}}
\end{aligned}
\end{equation}
$$</p>
<p>令
$$
K=\begin{bmatrix} K_{x, x^{\prime}} &amp; K_{x, y} \\ K_{x, y}&amp; K_{y, y^{\prime}} \end{bmatrix}
$$</p>
<p>$$
M=\begin{bmatrix}\frac{1}{n^{2}} &amp;-\frac{1}{n m} \\ -\frac{1}{n m}&amp; \frac{1}{m^{3}} \end{bmatrix}
$$</p>
<p>最后：
$$
\mathrm{M M D}^2(X,Y,\mathcal{F}_{\mathcal{H}_k}) = tr(KM)
$$</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Reproducing Kernel Hilbert Space</title>
      <link>https://JhuoW.github.io/posts/rkhs_kernel/</link>
      <pubDate>Sat, 26 Mar 2022 22:39:20 +0800</pubDate>
      
      <guid>https://JhuoW.github.io/posts/rkhs_kernel/</guid>
      <description>Hilbert Space Definition 1 (Norm) Let $\mathcal{F}$ be a vector space over $\mathbb{R}$ (For example $\mathcal{F}=\mathbb{R}^n$ is a vector space). A function $||\cdot||_{\mathcal{F}}: \mathcal{F} \to [0, \inf)$ is said to be a norm on $\mathcal{F}$ if ($||\cdot||_{\mathcal{F}}$ 是一个有效norm算子要满足以下条件):
 For $f \in \mathcal{F}$, $||f||_{\mathcal{F}}=0$ if and only if $f=0$. (norm separates points) $|\lambda f|_{\mathcal{F}}=|\lambda||f|_{\mathcal{F}}$, $\forall \lambda \in \mathbb{R}, \forall f \in \mathcal{F}$ (positive homogeneity). $|f+g|_{\mathcal{F}} \leq|f|_{\mathcal{F}}+|g|_{\mathcal{F}}, \forall f, g \in \mathcal{F}$ (triangle inequality).</description>
      <content:encoded><![CDATA[<h1 id="hilbert-space">Hilbert Space</h1>
<p><em><strong>Definition 1</strong></em> (<a href="http://www.stats.ox.ac.uk/~sejdinov/teaching/atml14/Theory_2014.pdf">Norm</a>) Let $\mathcal{F}$ be a vector space over $\mathbb{R}$ (For example $\mathcal{F}=\mathbb{R}^n$ is a vector space). A function $||\cdot||_{\mathcal{F}}: \mathcal{F} \to [0, \inf)$ is said to be a norm on $\mathcal{F}$ if ($||\cdot||_{\mathcal{F}}$ 是一个有效norm算子要满足以下条件):</p>
<ol>
<li>For $f \in \mathcal{F}$, $||f||_{\mathcal{F}}=0$ if and only if $f=0$. (norm separates points)</li>
<li>$|\lambda f|_{\mathcal{F}}=|\lambda||f|_{\mathcal{F}}$, $\forall \lambda \in \mathbb{R}, \forall f \in \mathcal{F}$ (positive homogeneity).</li>
<li>$|f+g|_{\mathcal{F}} \leq|f|_{\mathcal{F}}+|g|_{\mathcal{F}}, \forall f, g \in \mathcal{F}$ (triangle inequality).</li>
</ol>
<p>向$||\cdot||_{\mathcal{F}}$中输入任意一个向量，只要满足以上条件，那么$||\cdot||_{\mathcal{F}}$是一个valid norm operator.</p>
<h2 id="inner-product">Inner Product</h2>
<p>An <a href="https://ocw.mit.edu/courses/sloan-school-of-management/15-097-prediction-machine-learning-and-statistics-spring-2012/lecture-notes/MIT15_097S12_lec13.pdf">inner product</a> takes two elements of a vector space $\mathcal{X}$ and outputs a number. An inner product could be a usual dot product: $\langle\mathbf{u}, \mathbf{v}\rangle=\mathbf{u}^{\prime} \mathbf{v}=\sum_{i} u^{(i)} v^{(i)}$ (Inner Product can be Dot Product). Or the inner product could be something fancier（即内积不一定表示为点积的形式）. If an Inner Product $\langle \cdot,\cdot \rangle$ is valid, it <em><strong>MUST</strong></em>  satisfy the following conditions:</p>
<ol>
<li>
<p>Symmetry
$$\langle u, v\rangle=\langle v, u\rangle \quad \forall u, v \in \mathcal{X}$$</p>
</li>
<li>
<p>Bilinearity
$$\langle\alpha u+\beta v, w\rangle=\alpha\langle u, w\rangle+\beta\langle v, w\rangle \quad \forall u, v, w \in \mathcal{X}, \forall \alpha, \beta \in \mathbf{R}$$</p>
</li>
<li>
<p>Strict Positive Definiteness
$$
\begin{gathered}
\langle u, u\rangle \geq 0 \forall x \in \mathcal{X} \\
\langle u, u\rangle=0 \Longleftrightarrow u=0
\end{gathered}$$</p>
</li>
</ol>
<p>An  <em><strong>inner product space</strong></em> (or pre-Hilbert space) is a vector space together with an inner product. （包含内积运算的向量空间称为 内积空间，即可以定义内积运算的向量空间）。</p>
<p>Kernel is a kind of Inner Product. For example, the Gaussian kernel is defined as:
$$
\begin{equation}
\langle u, v \rangle = k(u,v) = \exp({-\frac{||u-v||^2}{2\sigma}}) \tag{1}
\end{equation}
$$</p>
<h2 id="hilbert-space-1">Hilbert Space</h2>
<p><em><strong>Definition 2</strong></em> (<a href="https://people.eecs.berkeley.edu/~bartlett/courses/281b-sp08/7.pdf">Hilbert Space</a>)  A Hilbert Space is an Inner Product space that is complete and separable with respect to the norm defined by the inner product.</p>
<p>&lsquo;Complete&rsquo; means sequences converge to elements of the space - there aren&rsquo;t any &ldquo;holes&rdquo; in the space.</p>
<h1 id="finite-states">Finite States</h1>
<p>Given finite input space ${x_1, x_2, \cdots x_m }$. I want to be able to take inner products between any two of them using my function $k$  as the inner product ($k$ is customized and satisfy three conditions. For example, $k$ is a Gaussian inner product as Eq.(1)). Inner products by definition are symmetric, so $k(x_i, x_j)=k(x_j, x_i)$ , which yields a symmetric matrix $\mathbf{K}$.</p>
<p>Since $\mathbf{K}$ is real symmetric, and this means we can diagonalize it （实对称阵可以对角化，即特征分解）, and the eigendecomposition takes this form:
$$
\begin{equation}
\begin{aligned}
\mathbf{K} &amp;=\mathbf{V} \Lambda \mathbf{V}^T \\
&amp;= \mathbf{V} 	\begin{bmatrix}
\lambda_1 &amp;   &amp; &amp;  \\
&amp; \lambda_2 &amp;  &amp; \\
&amp;   &amp; \cdots &amp;\
&amp;   &amp;  &amp;\lambda_m
\end{bmatrix} \mathbf{V}^T \\
&amp;= \begin{bmatrix}
v_1 &amp; v_2 &amp; \cdots v_m
\end{bmatrix} \begin{bmatrix}
\lambda_1 &amp;   &amp; &amp;  \\
&amp; \lambda_2 &amp;  &amp; \\
&amp;   &amp; \cdots &amp;\\
&amp;   &amp;  &amp;\lambda_m
\end{bmatrix}
\begin{bmatrix}
v_1^T\\
v_2^T\\
\cdots \\
v_m^T
\end{bmatrix}\\
&amp;=v_1\lambda_1 v_1^T + \cdots + v_m\lambda_m v_m^T = \sum_{t=1}^m v_t\lambda_tv_t^T
\end{aligned} \tag{2}
\end{equation}
$$
Let the $i$-th element of vector $v$ as $v^{(i)}$, then
$$
\begin{equation}
\begin{aligned}
\mathbf{K}_{ij} = k(x_i, x_j) &amp;= [\sum_{t=1}^m v_t\lambda_tv_t^T]_{ij}\\
&amp;=\sum^m_{t=1} v_t^{(i)} \lambda_t v_t^{(j)}
\end{aligned} \tag{3}
\end{equation}
$$
If $\mathbf{K}$ is a <strong>positive semi-definite</strong> (<strong>PSD</strong>) matrix, then $\lambda_1, \cdots \lambda_m \geq 0$.</p>
<blockquote>
<p><em><strong>Assumption 1</strong></em>. All $\lambda_t$ are nonnegative.</p>
</blockquote>
<p>We consider this feature map:
$$
\begin{equation}
\Phi\left(x_{i}\right)=\left[\sqrt{\lambda_{1}} v_{1}^{(i)}, \ldots, \sqrt{\lambda_{t}} v_{t}^{(i)}, \ldots, \sqrt{\lambda_{m}} v_{m}^{(i)}\right] \in \mathbb{R}^m \tag{4}
\end{equation}
$$
(writing it for $x_j$ too):
$$
\begin{equation}
\boldsymbol{\Phi}\left(x_{j}\right)=\left[\sqrt{\lambda_{1}} v_{1}^{(j)}, \ldots, \sqrt{\lambda_{t}} v_{t}^{(j)}, \ldots, \sqrt{\lambda_{m}} v_{m}^{(j)}\right]  \in \mathbb{R}^m \tag{5}
\end{equation}
$$
即 $\Phi: \mathcal{X} \to \mathbb{R}^m$ 将$x\in \mathcal{X}$映射到$m$维向量空间$\mathbb{R}^m$中的一个点。</p>
<p>With this choice, the inner product $k$ is just defined as a dot product in $\mathbb{R}^m$:
$$
\begin{equation}
\left\langle\Phi\left(x_{i}\right), \Phi\left(x_{j}\right)\right\rangle_{\mathbf{R}^{m}}=\sum_{t=1}^{m} \lambda_{t} v_{t}^{(i)} v_{t}^{(j)}=\left(\mathbf{V} \Lambda \mathbf{V}^{\prime}\right)_{i j}=K_{i j}=k\left(x_{i}, x_{j}\right)  \tag{6}
\end{equation}
$$
If there exists an eigenvalue $\lambda_s &lt;0$ (即$\sqrt{\lambda_s} = \sqrt{|\lambda_s|} i$). $\lambda_s$对应的特征向量$v_s$。用$v_s \in \mathbb{R}^m$的$m$个元素$v_s = [v_s^{(1)},\cdots, v_s^{(m)}]$, 来对$\Phi(x_1),\cdots, \Phi(x_m)$做线性组合：
$$
\begin{equation}
\mathbf{z}=\sum_{i=1}^{m} v_{s}^{(i)} \boldsymbol{\Phi}\left(x_{i}\right) \tag{7}
\end{equation}
$$</p>
<p>It is obvious that $\mathbf{z} \in \mathbb{R}^m$. Then calculate
$$
\begin{equation}
\begin{aligned}
|\mathbf{z}|_{2}^{2} &amp;=\langle\mathbf{z}, \mathbf{z}\rangle_{\mathbf{R}^{m}}=\sum_{i} \sum_{j} v_{s}^{(i)} \boldsymbol{\Phi}\left(x_{i}\right)^{T} \boldsymbol{\Phi}\left(x_{j}\right) v_{s}^{(j)}=\sum_{i} \sum_{j} v_{s}^{(i)} K_{i j} v_{s}^{(j)} \\
&amp;=\mathbf{v}_{s}^{T} \mathbf{K} \mathbf{v}_{s}=\lambda_{s}&lt;0
\end{aligned}  \tag{8}
\end{equation}
$$
which conflicts with the geometry of the feature space.</p>
<p>如果$\mathbf{K}$不是半正定，那么feature space $\mathbb{R}^m$存在小于0的值。所以假设Assumption不成立。即，若$k$表示有限集的内积，那么它的Gram Matrix一定半正定(PSD)，否则无法保证该空间中的norm大于0。</p>
<p>有效的内积对应的Gram Matrix 必定PSD.</p>
<h1 id="kernel">Kernel</h1>
<p><em><strong>Definition 3.</strong></em> (<a href="https://ocw.mit.edu/courses/sloan-school-of-management/15-097-prediction-machine-learning-and-statistics-spring-2012/lecture-notes/MIT15_097S12_lec13.pdf">Kernel</a>) A function $k: \mathcal{X} \times \mathcal{X} \to \mathbb{R}$ is a kernel if</p>
<ol>
<li>$k$ is symmetric: $k(x,y) = k(y,x)$.</li>
<li>$k$ gives rise to a positive semi-definite &ldquo;Gram matrix,&rdquo; i.e., for any $m\in \mathbb{N}$ and any $x_1,\cdots,x_m$ chosen from $X$, the Gram matrix $\mathbf{K}$ defined by $\mathbf{K}_{ij} = k(x_i,x_j)$ is positive semi-definite.</li>
</ol>
<p>Another way to show that a matrix $\mathbf{K}$ is positive semi-definite is to show that
$$
\begin{equation}
\forall \mathbf{c} \in \mathbf{R}^{m}, \mathbf{c}^{T} \mathbf{K} \mathbf{c} \geq 0 \tag{9}
\end{equation}
$$
Here are some nice properties of $k$:</p>
<ul>
<li>$k(u,u) \geq 0$ (Think about the Gram matrix of $m = 1$.)</li>
<li>$k(u, v) \leq \sqrt{k(u, u) k(v, v)}$ (This is the Cauchy-Schwarz inequality.)</li>
</ul>
<h2 id="reproducing-kernel-hilbert-space-rkhs">Reproducing Kernel Hilbert Space (RKHS)</h2>
<p>给定一个kernel $k(\cdot, \cdot): \mathcal{X} \times \mathcal{X} \to \mathbb{R}$. 定义一个函数空间（space of functions）$\mathbf{R}^{\mathcal{X}}:={f: \mathcal{X} \rightarrow \mathbb{R}}$. $\mathbf{R}^{\mathcal{X}}$ 是一个 Hilbert Space， 该空间中的每个元素是一个$\mathcal{X}$映射到$\mathbb{R}$的函数。</p>
<p>令$k_x(\cdot) = k(x, \cdot)$, 假设$x$是一个定值（Constant），自变量（输入）用$\cdot$表示。那么$k(x, \cdot)$ 也是$\mathbf{R}^{\mathcal{X}}$空间中的一个函数。</p>
<p>每个函数$k_x(\cdot)$ 都与一个特定的$x \in \mathcal{X}$有关，即每个$x$对应于一个函数$k_x(\cdot) = k(\cdot, x)$. 这种对应关系表示为$\Phi(x) = k_x(\cdot) = k(x,\cdot)$, 即：
$$
\begin{equation}
\Phi: x \longmapsto k(\cdot, x) \tag{10}
\end{equation}
$$
即 $\Phi$的输入为$x\in \mathcal{X}$, 输出一个函数, 输出的函数属于$\mathbf{R}^{\mathcal{X}}$空间。</p>
<p>在连续空间$\mathcal{X}$中，$x \in \mathcal{X}$ 有无穷多种情况，那么$\Phi(x)=k_x(\cdot)=k(x, \cdot)$也有无穷多种情况，即无穷多种函数。 这些函数可以span 一个Hilbert Space:
$$
\begin{equation}
\mathcal{H}_k = \operatorname{span}({\Phi(x): x \in \mathcal{X}})=\left\{f(\cdot)=\sum_{i=1}^{m} \alpha_{i} k\left(\cdot, x_{i}\right): m \in \mathbf{N}, x_{i} \in \mathcal{X}, \alpha_{i} \in \mathbf{R}\right\}  \tag{11}
\end{equation}
$$
其中$k(x,\cdot)=\Phi(x)$可以理解为将$x$映射为一个函数（or vector）。上述Hilbert Space是由任意$k(x, \cdot)$线性组合而成的函数空间，该空间中的每个元素可以表示为
$$
\begin{equation}
f(\cdot)=\sum_{i=1}^{m} \alpha_{i} k\left(\cdot, x_{i}\right)  \tag{12}
\end{equation}
$$
所以$\mathcal{H}$可以看作是kernel $k$对应的一个Hilbert Space。</p>
<p>给定$\mathcal{H}$中的任意两个函数$f(\cdot)=\sum_{i=1}^{m} \alpha_{i} k\left(\cdot, x_{i}\right)$, $g(\cdot)=\sum_{j=1}^{m^{\prime}} \beta_{j} k\left(\cdot, x_{j}^{\prime}\right)$。注意$f(\cdot)$和$g(\cdot)$可以表示$\mathcal{H}$中任意两个元素。我们将$\mathcal{H}$上的内积定义为：
$$
\begin{equation}
\langle f, g\rangle_{\mathcal{H}_{k}}=\sum_{i=1}^{m} \sum_{j=1}^{m^{\prime}} \alpha_{i} \beta_{j} k\left(x_{i}, x_{j}^{\prime}\right) \tag{13}
\end{equation}
$$
由<a href="https://ocw.mit.edu/courses/sloan-school-of-management/15-097-prediction-machine-learning-and-statistics-spring-2012/lecture-notes/MIT15_097S12_lec13.pdf">Proof</a>证明了该内积符合三个条件，顾上式是$\mathcal{H}$空间中一个有效的内积算子。注：$\mathcal{H}_k$表示该Hilbert Space是由函数 $k(x,\cdot)$ span而成的，与Kernel $k$有关.</p>
<p>$k(x,\cdot)$也是$\mathcal{H}_k$中的一个函数，那么它与 $f$的内积为：
$$
\begin{equation}
\langle k(\cdot, x), f\rangle_{\mathcal{H}_{k}}=
\sum_{i=1}^m \alpha_i k(x,x_i)
=f(x) \tag{14}
\end{equation}
$$
<strong>Theorem 1.</strong>  $k(\cdot, \cdot)$ is a reproducing kernel of a Hilbert space $\mathcal{H}_k$ if $f(x)=\langle k(x, \cdot), f(\cdot)\rangle$.</p>
<p>$\mathcal{H}_k$ 为$k(\cdot, \cdot)$的再生核希尔伯特空间。</p>
<p>同理，$k(\cdot, x_i)$, $k(\cdot, x_j)$都为$\mathcal{H}_k$中的函数， 计算他们的内积:
$$
\begin{equation}
\left\langle k(\cdot, x_i), k\left(\cdot, x_j\right)\right\rangle_{\mathcal{H}_{k}}=k\left(x_i, x_j\right)  \tag{15}
\end{equation}
$$
因为$ k(\cdot, x_i) = \Phi(x_i)$, $ k(\cdot, x_j) = \Phi(x_j)$, 所以
$$
\begin{equation}
k\left(x_i, x_j\right) = \left\langle  \Phi(x_i), \Phi(x_j)\right\rangle_{\mathcal{H}_{k}} \tag{16}
\end{equation}
$$
表示将$x_i$和$x_j$ 映射成$\mathcal{H}_k$中的函数（向量）后再做内积。</p>
<h4 id="参考文献">参考文献</h4>
<p>[1] <a href="https://people.eecs.berkeley.edu/~bartlett/courses/281b-sp08/7.pdf">https://people.eecs.berkeley.edu/~bartlett/courses/281b-sp08/7.pdf</a></p>
<p>[2] <a href="http://www.stats.ox.ac.uk/~sejdinov/teaching/atml14/Theory_2014.pdf">http://www.stats.ox.ac.uk/~sejdinov/teaching/atml14/Theory_2014.pdf</a></p>
<p>[3] <a href="https://ocw.mit.edu/courses/sloan-school-of-management/15-097-prediction-machine-learning-and-statistics-spring-2012/lecture-notes/MIT15_097S12_lec13.pdf">https://ocw.mit.edu/courses/sloan-school-of-management/15-097-prediction-machine-learning-and-statistics-spring-2012/lecture-notes/MIT15_097S12_lec13.pdf</a></p>
<p>我把本文整理成了<a href="/posts/rkhs/RKHS.pdf">PDF</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Monte Carlo Tree Search</title>
      <link>https://JhuoW.github.io/posts/monte-carlo-tree-search/</link>
      <pubDate>Fri, 25 Mar 2022 18:09:58 +0800</pubDate>
      
      <guid>https://JhuoW.github.io/posts/monte-carlo-tree-search/</guid>
      <description>单一状态Monte Carlo规划：多臂赌博机（Multi-armed bandits） 单一状态$s$, $k$种action（$k$个摇臂）。
在摇臂赌博机问题中，$s$每次以随机采样形式采取一种行动$a$。 例如，随机拉动第$k$个赌博机，得到的reward为$R(s, a_k)$。问下一次拉动哪个赌博机，才能获得最大Reward?
多臂赌博机问题是一种序列决策问题，这种问题需要在利用（exploitation）和探索（exploration）之间保持平衡。
  利用（Exploitation）： 保证在过去决策中得到最佳回报
  探索（Exploration）：寄希望在未来能够得到更大的汇报
  例如， $s$摇动10次赌博机，其中第5次获得最大回报，那么下一次摇动赌博机可能选第5个赌博机，即“利用”（根据过去的最佳回报来施展下一次行为），第11次摇动的action为$a_5$。
但是摇动10次后，可能有的赌博机尚未摇动，未摇动的赌博机可能会有更大回报，即“探索”。
悔值函数 如果有$k$个赌博机， 这$k$个赌博机产生的操作序列为$X_{i,1}, X_{i,2}, \cdots (i = 1,\cdots, k)$。 在时刻$t=1,2,\cdots$, 选择第$I_t$个赌博机后，可得到的奖励为$X_{I_t,t}$, 则在$n$次操作$I_1,\cdots,I_n$后，可如下定义悔值函数： $$ R_n = \max_{i=1,\cdots,k} \sum^n_{t = 1} X_{i,t}-\sum^n_{t=1}X_{I_t, t} $$ $i$: 第$i$个赌博机
$I_t$: $t$时刻选择的赌博机
$\max_{i=1,\cdots,k} \sum^n_{t = 1} X_{i,t}$: 最理想（大）的奖励
$X_{I_t, t}$: $t$时刻选择赌博机$I_t$的reward
$\sum^n_{t=1}X_{I_t, t}$: $n$次选择的总奖励。
$R_n$越大，就代表$n$次决策的结果越差。
上置信区间（Upper Confidence Bound, UCB） UCB旨在探索和利用间去的平衡
在UCB方法中，使$X_{i, T_{i}(t-1)}$ 来记录第$i$个赌博机在过去$t-1$时刻内的平均奖励，则在第$t$时刻，选择使如下具有最佳上限置信区间的赌博机： $$ I_{t}=\max_{i \in{1, \ldots, k}}\left\{\overline{X_{i, T_{i}(t-1)}}+C_{t-1, T_{i}(t-1)} \right\}.</description>
      <content:encoded><![CDATA[<h1 id="单一状态monte-carlo规划多臂赌博机multi-armed-bandits">单一状态Monte Carlo规划：多臂赌博机（Multi-armed bandits）</h1>
<p>单一状态$s$, $k$种action（$k$个摇臂）。</p>
<p>在摇臂赌博机问题中，$s$每次以随机采样形式采取一种行动$a$。 例如，随机拉动第$k$个赌博机，得到的reward为$R(s, a_k)$。问下一次拉动哪个赌博机，才能获得最大Reward?</p>
<p>多臂赌博机问题是一种序列决策问题，这种问题需要在利用（exploitation）和探索（exploration）之间保持平衡。</p>
<ul>
<li>
<p>利用（Exploitation）： 保证在过去决策中得到最佳回报</p>
</li>
<li>
<p>探索（Exploration）：寄希望在未来能够得到更大的汇报</p>
</li>
</ul>
<p>例如， $s$摇动10次赌博机，其中第5次获得最大回报，那么下一次摇动赌博机可能选第5个赌博机，即“利用”（根据过去的最佳回报来施展下一次行为），第11次摇动的action为$a_5$。</p>
<p>但是摇动10次后，可能有的赌博机尚未摇动，未摇动的赌博机可能会有更大回报，即“探索”。</p>
<h2 id="悔值函数">悔值函数</h2>
<p>如果有$k$个赌博机， 这$k$个赌博机产生的操作序列为$X_{i,1}, X_{i,2}, \cdots (i = 1,\cdots, k)$。 在时刻$t=1,2,\cdots$, 选择第$I_t$个赌博机后，可得到的奖励为$X_{I_t,t}$, 则在$n$次操作$I_1,\cdots,I_n$后，可如下定义悔值函数：
$$
R_n = \max_{i=1,\cdots,k} \sum^n_{t = 1} X_{i,t}-\sum^n_{t=1}X_{I_t, t}
$$
$i$: 第$i$个赌博机</p>
<p>$I_t$: $t$时刻选择的赌博机</p>
<p>$\max_{i=1,\cdots,k} \sum^n_{t = 1} X_{i,t}$: 最理想（大）的奖励</p>
<p>$X_{I_t, t}$: $t$时刻选择赌博机$I_t$的reward</p>
<p>$\sum^n_{t=1}X_{I_t, t}$: $n$次选择的总奖励。</p>
<p>$R_n$越大，就代表$n$次决策的结果越差。</p>
<h2 id="上置信区间upper-confidence-bound-ucb">上置信区间（Upper Confidence Bound, UCB）</h2>
<p>UCB旨在探索和利用间去的平衡</p>
<p>在UCB方法中，使$X_{i, T_{i}(t-1)}$ 来记录第$i$个赌博机在过去$t-1$时刻内的平均奖励，则在第$t$时刻，选择使如下具有最佳上限置信区间的赌博机：
$$
I_{t}=\max_{i \in{1, \ldots, k}}\left\{\overline{X_{i, T_{i}(t-1)}}+C_{t-1, T_{i}(t-1)} \right\}.
$$
其中$I_{t}$为$t$时刻要摇的赌博机，</p>
<p>$\overline{X_{i, T_{i}(t-1)}}$要尽可能大：为$t$时刻之前赌博机$i$的平均reward 要尽可能大，</p>
<p>$C_{t-1, T_{i}(t-1)}$要尽可能小：$t$时刻之前$i$出现的次数要尽可能少</p>
<p>其中$C_{t,T_i(t)}$的取值定义如下：
$$
C_{t,T_i(t)}=\sqrt{\frac{2 \operatorname{In} t}{T_i(t)}}
$$
其中$T_i(t)$表示 $t$时刻以前（包括$t$），选到赌博机$i$的次数总和。</p>
<p>若赌博机在$t$时刻之前（包括$t$）时刻摇动的次数越少，$C_{t,T_i(t)}$越大</p>
<p>选出的$I_t$要满足在$t$之前的平均reward尽可能大（利用）， 且在$t$之前出现次数尽可能少（探索）。</p>
<p>也就是说，在第时刻，UCB算法一般会选择具有如下最大值的第$j$个赌博机：
$$
\begin{aligned}
U C B&amp;=\bar{X}_{j}+\sqrt{\frac{2 \operatorname{Inn}}{n_{j}}} \text { 或者 } U C B=\bar{X}_{j}+C \times \sqrt{\frac{2 \operatorname{In} n}{n_{j}}} \\
I_t &amp;= \mathrm{argmax}_j UCB(j)
\end{aligned}
$$
其中$\bar{X}_{j}$是第$j$个赌博机在过去时间内所获得的平均奖赏值，$n_j$是在过去时间内拉动第$j$个赌博机臂膀的总次数，$n$是过去时间内拉动所有赌博机臂膀的总次数。$C$是一个平衡因子，其决定着在选择时偏重探索还是利用。</p>
<p>从这里可看出UCB算法如何在探索-利用(exploration-exploitation)之间寻找平衡：既需要拉动在过去时间内获得最大平均奖赏的赌博机，又希望去选择拉动臂膀次数最少的赌博机。</p>
<h1 id="monte-carlo-tree-search">Monte Carlo Tree Search</h1>
<p>MCTS has four step:</p>
<ul>
<li>Selection 选择</li>
<li>Expansion 拓展</li>
<li>Simulation（rollout) 模拟</li>
<li>Backpropagation 回溯</li>
</ul>
<p><img loading="lazy" src="/posts/2022-03-30-MCTS/1.png#center" alt=""  />
</p>
<h2 id="选择">选择</h2>
<p>从根节点R开始，向下递归选择子节点，直至选择一个叶子节点L。
具体来说，通常用UCBl(Upper Confidence Bound,上限置信区间)选择最具“潜力”的后续节点：
$$
U C B=\bar{X}_{j}+\sqrt{\frac{2 \operatorname{In} n}{n_{j}}}
$$</p>
<h2 id="拓展">拓展</h2>
<p>如果L不是一个终止节点（即博弈游戏不)，则随机创建其后的一个未被访问节点，选择该节点作为后续子节点C。</p>
<h2 id="模拟">模拟</h2>
<p>从节点C出发，对游戏进行模拟，直到博弈游戏结束。</p>
<h2 id="反向传播">反向传播</h2>
<p>用模拟所得结果来回溯更新导致这个结果的每个节点中获胜次数和访问次数。</p>
<p><strong>包含两种策略学习机制：</strong></p>
<p><strong>搜索树策略</strong>：从已有的搜索树中选择或创建一个叶子结点（即蒙特卡洛中选择和拓展两个步骤).搜索树策略需要在利用和探索之间保持平衡。</p>
<p><strong>模拟策略</strong>：从非叶子结点出发模拟游戏，得到游戏仿真结果。</p>
<h1 id="例子-围棋">例子： 围棋</h1>
<ul>
<li>
<p>以围棋为例，假设根节点是执黑棋方。</p>
</li>
<li>
<p>图中每一个节点都代表一个局面，每一个局面记录两个值A/B</p>
</li>
</ul>
<p>A: 该局面被访问中黑棋胜利次数。对于黑棋表示己方胜利次数，对于白棋表示己方失败次数（对方胜利次数)；</p>
<p>B: 该局面被访问的总次数</p>
<p>初始状态：<img loading="lazy" src="/posts/2022-03-30-MCTS/wq1.png#center" alt=""  />
</p>
<p>根节点（12/21）是当前局面，该局面被访问过21次，其中黑棋访问该局面后最终获胜12次。 黑执棋方遇到该局面（根节点局面）开始选择下一步action。</p>
<h3 id="选择-1">选择</h3>
<p>黑执棋方遇到（12/21）这个局面时有3个有效action, 黑执行这三个action会得到3种局面（7/10）,（5/8）, (0/3). 黑执棋方要选择其中一个action，是的棋局变为这三种中的一种，那么要如何选择action呢？我们先分别计算UCB1：</p>
<p>左一： 7/10对应的局面Reward为：
$$
\frac{7}{10} + \sqrt{\frac{\log (21)}{10}} = 1.252
$$
3中局面共21次被模拟到，其中，该局面被访问过10次（探索， 第二项）， 黑棋遇到该局面后最终获胜7次（利用， 第一项）。</p>
<p>左二：（5/8）对应局面Reward:
$$
\frac{5}{8} + \sqrt{\frac{\log(21)}{8}} = 1.243
$$
左三： （0/3）对应局面Reward:
$$
\frac{0}{3} + \sqrt{\frac{\log(21)}{3}} = 1.007
$$
由此可见，黑棋选择会导致局面（7/10）的action进行走琪。</p>
<p><img loading="lazy" src="/posts/2022-03-30-MCTS/wq1.png#center" alt=""  />
</p>
<p>白棋遇到局面（7/10）时，有两个有效的action, 分别会导致局面A/B = 2/4和5/6, A为白棋访问该局面后失败的次数，所以白棋访问该局面最终胜利的次数应该是$B-A$：</p>
<p>左一： (2/4)对应的局面Reward (白棋尽可能获胜)为：
$$
(1-\frac{2}{4}) + \sqrt{\frac{\log(21)}{4}}=1.372
$$
左二：  (5/6)对应的局面Reward为：
$$
(1-\frac{5}{6}) + \sqrt{\frac{\log(21)}{4}}=0.879
$$
因此白棋会选择（2/4）局面</p>
<p>即<strong>每一步都寻找最佳应对方式，来最终评估更节点局面的好坏</strong></p>
<p><img loading="lazy" src="/posts/2022-03-30-MCTS/wq1.png#center" alt=""  />
</p>
<p>白色执棋方选择action后到达局面（2/4）, 黑棋执棋方面对该局面，有两种action可选，分别会到达（1/3）和（1/1）， 分别计算UCB1 得：</p>
<p>左一： (1/3)对应reward 为：
$$
\frac{1}{3} + \sqrt{\frac{\log (21)}{3}} = 1.341
$$
左二：(1/1)对应reward为：
$$
\frac{1}{1} + \sqrt{\frac{\log (21)}{1}} = 2.745
$$
则黑棋选择action 使得局面变为(1/1)。右图中可见(1/1)为叶子节点， 白棋面对该局面暂时无候选局面（action）,则进入下一个步骤，拓展。</p>
<h3 id="拓展-1">拓展</h3>
<p><img loading="lazy" src="/posts/2022-03-30-MCTS/wq1.png#center" alt=""  />
</p>
<p>白棋执棋方面对局面(1/1),因为已经是叶子节点， 所以(1/1)会随机产生一个未被访问过的新节点，初始化为(0/0),接着在该节点下进行模拟。 进入第三部， 模拟。</p>
<h3 id="模拟-1">模拟</h3>
<p><img loading="lazy" src="/posts/2022-03-30-MCTS/wq3.png#center" alt=""  />
</p>
<p>黑棋执棋方面局面（0/0），开始进行游戏仿真， 假设经过一些列仿真后，最终白棋获胜，即从更节点到最终模拟结束的叶子节点黑棋失败了。 进入第四部，回溯</p>
<h3 id="回溯">回溯</h3>
<p><img loading="lazy" src="/posts/2022-03-30-MCTS/wq4.png#center" alt=""  />
</p>
<p>根据仿真结果来更新该仿真路径上的每个节点的A/B值。 因为该次模拟最终白棋获胜，所以向上回溯路径上的所有父节点，父节点的A不变，B+1。 若最终黑棋获胜，则父节点的A+1, B+1。</p>
<p><strong>在有限时间里， MCTS会不断重复4个步骤，所有节点的A,B 值会不断变化</strong></p>
<p><strong>到某个局面（节点）后如何下棋（action）, 会选择所有有效Action中UCB1值最大的节点，作为下棋的下一步。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Notes for Spectral Clustering</title>
      <link>https://JhuoW.github.io/posts/2019-09-07-spectral-clustering/</link>
      <pubDate>Sat, 07 Sep 2019 09:11:09 +0000</pubDate>
      
      <guid>https://JhuoW.github.io/posts/2019-09-07-spectral-clustering/</guid>
      <description>最近在看GNN/GCN的时候遇到谱聚类，学了下，做了些笔记。
本文主要参考了：[1] https://www.cnblogs.com/pinard/p/6221564.html#!comments
Introduction 谱聚类是图论中的算法，主要思想是空间中距离较远的两个点之间边的权重值较低， 距离较近的两个点之间边的权重值较高， 通过对所有数据点组成的图（Graph）进行切图， 使不同子图之间边的权重和尽可能低， 子图内边的权重值的和尽可能高，从而达到聚类的目的。
基础1： 无向权重图 对于边$(v_i,v_j)$, 它的权重$w_{ij} &amp;gt; 0$。对于没有边的节点$v_i$和$v_j$, 他们之间的权重$w_{ij}=0$。图中的节点$v_i$, 它的度$d_i$定义为和它连接的所有边的权重之和，即： $$ d_i = \sum_{j=1}^n w_{ij} $$ 根据所有节点的度值，我们可以得到一个度矩阵$D$: $$ D=\displaystyle \left(\begin{array}{ccc}{d_{1}} &amp;amp; {\ldots} &amp;amp; {\ldots} \\\ {\ldots} &amp;amp; {d_{2}} &amp;amp; {\ldots} \\\ {\vdots} &amp;amp; {\vdots} &amp;amp; {\ddots} \\\ {\ldots} &amp;amp; {\ldots} &amp;amp; {d_{n}}\end{array}\right) ^{n\times n} $$ 是一个$n \times n$的对角阵，对角元素是每个节点的度和。
定义图的邻接矩阵为$W \in \mathbb{R}^{n \times n}$， 每个元素$W_{ij}$表示节点对$(v_i,v_j)$之间的权重。 对于$V$中的一个子节点集$A \subset V$， 定义： $$|A|=A 中的节点个数 $$
$$vol(A) = \sum_{i \in A} d_i \quad 表示A中所有节点的权重之和$$</description>
      <content:encoded><![CDATA[<p>最近在看GNN/GCN的时候遇到谱聚类，学了下，做了些笔记。</p>
<p>本文主要参考了：[1] <a href="https://www.cnblogs.com/pinard/p/6221564.html#!comments">https://www.cnblogs.com/pinard/p/6221564.html#!comments</a></p>
<h1 id="introduction">Introduction</h1>
<p>谱聚类是图论中的算法，主要思想是空间中距离较远的两个点之间边的权重值较低， 距离较近的两个点之间边的权重值较高， 通过对所有数据点组成的图（Graph）进行切图， 使不同子图之间边的权重和尽可能低， 子图内边的权重值的和尽可能高，从而达到聚类的目的。</p>
<h1 id="基础1-无向权重图">基础1： 无向权重图</h1>
<p>对于边$(v_i,v_j)$, 它的权重$w_{ij} &gt; 0$。对于没有边的节点$v_i$和$v_j$,  他们之间的权重$w_{ij}=0$。图中的节点$v_i$, 它的度$d_i$定义为和它连接的所有边的权重之和，即：
$$
d_i = \sum_{j=1}^n w_{ij}
$$
根据所有节点的度值，我们可以得到一个度矩阵$D$:
$$
D=\displaystyle \left(\begin{array}{ccc}{d_{1}} &amp; {\ldots} &amp; {\ldots} \\\ {\ldots} &amp; {d_{2}} &amp; {\ldots} \\\ {\vdots} &amp; {\vdots} &amp; {\ddots} \\\ {\ldots} &amp; {\ldots} &amp; {d_{n}}\end{array}\right) ^{n\times n}
$$
是一个$n \times n$的对角阵，对角元素是每个节点的度和。</p>
<p>定义图的邻接矩阵为$W \in \mathbb{R}^{n \times n}$， 每个元素$W_{ij}$表示节点对$(v_i,v_j)$之间的权重。 对于$V$中的一个子节点集$A \subset V$， 定义：
$$|A|=A 中的节点个数 $$</p>
<p>$$vol(A) = \sum_{i \in A} d_i \quad 表示A中所有节点的权重之和$$</p>
<h1 id="基础2相似矩阵">基础2：相似矩阵</h1>
<p>再提下谱聚类的基本思想： 距离较远的两个点之间权重值较低，距离较近的两个点之间权重值较高</p>
<p>但是在谱聚类中，我们只能获得数据点的定义，无法给出邻接矩阵，因为是离散的分布在空间中，无法得知其中的连接关系。</p>
<p>一般来说，通过样本点距离度量的相似矩阵$S$来获得邻接矩阵$W$.</p>
<p>构建邻接矩阵$W$有两种方法: $\epsilon$-邻近法， K邻近法和全连接法。</p>
<h2 id="epsilon-邻近法">$\epsilon$-邻近法</h2>
<p>$\epsilon$为距离的阈值，欧式距离$S_{ij}$表示两点$v_i$,$v_j$的坐标$x_i$,$x_j$之间的距离。 即 $S_{ij} =||x_i-x_j||^2_2$为相似矩阵$S \in \mathbb{R}^{n \times n}$的第$i$行第$j$个元素，则邻接矩阵$W$可以表示为：</p>
<p>$$
w_{ij}=\left\{\begin{array}{ll}{0} &amp; {s_{i j}&gt;\epsilon} \\  {\epsilon} &amp; {s_{i j} \leq \epsilon}\end{array}\right.
$$</p>
<p>意思是如果两点之间的距离大于$\epsilon$，那么他们之间的权重为0， 如果他们之间的距离小于$\epsilon$，他们之间的权重为$\epsilon$。 这种方法的弊端在于点之间的距离只有两种情况，不够精确，故很少采用。</p>
<h2 id="k邻近法">K邻近法</h2>
<p>利用<strong>KNN</strong>算法遍历所有样本点，取每个样本点最近的$k$个点作为近邻，只有和样本点距离最近的$k$个点的$w_{ij} &gt;0$，但会出现一种情况， $v_i$的k个近邻中有$v_j$，但$v_j$的k个近邻中没有$v_i$，这样会造成邻接矩阵$W$的不对称， 因此提供两种解决办法</p>
<p>第一种： 只要$v_j$在$v_i$的K邻域中，那么不管$v_i$在不在$v_j$的K邻域中，都把$v_i$加入$v_j$的邻域中，即：</p>
<p>$$
w_{i j}=w_{j i}=\left\{\begin{array}{ll}{0} &amp; {x_{i} \notin K N N\left(x_{j}\right) \text { and } x_{j} \notin K N N\left(x_{i}\right)} \\ {\exp \left(-\frac{\left||x_{i}-x_{j}\right||^2_2}{2 \sigma^{2}}\right)} &amp; {x_{i} \in K N N\left(x_{j}\right) \text { or } x_{j} \in K N N\left(x_{i}\right)}\end{array}\right.
$$
第二种，必须$v_i$在$v_j$的K邻域中，且$v_j$在$v_i$的K邻域中，那么才保留两者间的权重，否则都为0，即：</p>
<p>$$
w_{i j}=w_{j i}=\left\{\begin{array}{ll}{0} &amp; {x_{i} \notin K N N\left(x_{j}\right) \text { or } x_{j} \notin K N N\left(x_{i}\right)} \\ {\exp \left(-\frac{||x_{i}-x_{j}||^2_2}{2 \sigma^{2}}\right)} &amp; {x_{i} \in K N N\left(x_{j}\right) \text { and } x_{j} \in K N N\left(x_{i}\right)}\end{array}\right.
$$</p>
<h2 id="全连接法">全连接法</h2>
<p>设所有点之间的权重都大于0，可以选择不同的核函数来定义边的权重，常用的如多项式核函数，高斯核函数， Sigmod核函数。 最常用的为高斯核函数RBF，将两点之间的距离带入高斯核函数RBF中，即：
$$
w_{i j}=w_{ji}=s_{i j}=s_{ji}=\exp \left(-\frac{\left|x_{i}-x_{j}\right|_{2}^{2}}{2 \sigma^{2}}\right)
$$
其中，$sigma$为为函数的宽度参数 , 控制了函数的径向作用范围。</p>
<h1 id="基础3拉普拉斯矩阵">基础3：拉普拉斯矩阵</h1>
<p>拉普拉斯矩阵定义为$L = D-W$ 如上文所示，$D$为度矩阵，$W$为邻接矩阵。</p>
<p>拉普拉斯矩阵具有如下性质：</p>
<ol>
<li>
<p>$L$是对称阵 （因为$D$和$W$都是对称阵）</p>
</li>
<li>
<p>$L$的所有特征值都是实数 （因为$L$是对称阵）</p>
</li>
<li>
<p>对于任意向量$f$， 有$f^TLf = \displaystyle \frac{1}{2} \sum_{i = 1}^n \sum_{j = 1}^n w_{ij} (f_i-f_j)^2$</p>
<p>推导：
$$
\begin{aligned}
f^TLf &amp;= f^TDf-f^TWf\\
&amp;= \sum^n_{i = 1}d_if_i^2 - \sum_{i = 1}^n\sum_{j =1}^n f_if_j w_{ij}\\
&amp;= \frac{1}{2}\left(\sum^n_{i=1}d_if_i^2 -2\sum_{i = 1}^n\sum_{j =1}^n f_if_j w_{ij} + \sum^n_{i=1}d_if_i^2\right)\\
&amp;由于d_i = \sum_{j = 1}^nw_{ij}, 将d_i带入上式得\\
f^TLf &amp;= \frac{1}{2} \left(\sum_{i = 1}^n\sum_{j =1}^n w_{ij}f_i^2-2\sum_{i = 1}^n\sum_{j =1}^n f_if_j w_{ij} + \sum_{i = 1}^n\sum_{j =1}^n w_{ij}f_i^2\right)\\
&amp; = \frac{1}{2} \left(\sum_{i = 1}^n\sum_{j =1}^n w_{ij}f_i^2-2\sum_{i = 1}^n\sum_{j =1}^n f_if_j w_{ij} + \sum_{j = 1}^n\sum_{i =1}^n w_{ji}f_j^2\right)\\
&amp;= \frac{1}{2}\left(\sum_{i=1}^n\sum_{j = 1}^n w_{ij} (f_i-f_j)^2\right)
\end{aligned}
$$</p>
</li>
<li>
<p>拉普帕斯矩阵是半正定的，且$n$个实数特征值都$\geq$，即 $0=\lambda_1 \leq \lambda_2 \cdots \leq \lambda_n$，且最小的特征值为0。</p>
<p>证明，因为$f^TLf \geq 0$ 所以$L$半正定。</p>
</li>
</ol>
<h1 id="基础4无向图切图">基础4：无向图切图</h1>
<p>对于无向图$G$，目的是将图$G = (v,E)$切成相互没有连接的k个子图，每个子图是一个节点集合：$A_1,A_2,\cdots, A_k$，满足$A_i \cap A_j = \phi$ 且$A_1 \cup A_2 \cup \cdots \cup A_k = V$，对于两个节点集合$A ,B \subset V$, $A \cap B = \phi$，定义$A$,$B$之间的切图权重为：
$$
W(A,B) = \sum_{v_i\in A, v_j \in B} w_{ij}  \quad 表示A中节点到B中节点的权重和
$$
对于$k$个子图节点集合$A_1,A_2,\cdots, A_k$，定义切图$Cut$为：
$$
Cut(A_1,A_2, \cdots, A_k) = \frac{1}{2}\sum^k_{i = 1} W(A_i,\overline{A_i})
$$
其中$\overline{A_i}$是$A_i$的补集，也就是除$A_i$外其他所有节点的集合，$Cut$计算的是$A_i$中每个节点到$\overline{A_i}$中每个节点的权重总和，如果最小化$Cut$，就相当于最小化每个子集中节点到自己外节点的权重，但是会存在一个问题，如下图所示：</p>
<p><img loading="lazy" src="1.jpg" alt=""  />
</p>
<p>如果按左边那条线分割，可以保证有边子图到左边子图的权重最小，但不是最佳分割。</p>
<h1 id="谱聚类切图聚类">谱聚类：切图聚类</h1>
<p>为了避免上述效果不佳的情况，提供两种切图方式，1.RatioCut, 2.Ncut.</p>
<h2 id="ratiocut-切图">RatioCut 切图</h2>
<p>最小化$Cut(A_1,A_2, \cdots, A_k)$的同时，最大化每个子图中接待你的个数，即：A_{i}, \overline{A}_{i}</p>
<p>$$RatioCut\left(A_{1}, A_{2}, \ldots A_{k}\right)=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \overline{A_i}\right)}{\left|A_{i}\right|}$$</p>
<p>目标是最小化$RatioCut\left(A_{1}, A_{2}, \ldots A_{k}\right)$。</p>
<p>为此，我们引入一个<strong>指示向量（indicator vector）</strong>$h_j \in {h_1,h_2,\cdots, h_k}$，其中$j = 1,2,\cdots,k$，对于其中任意一个向量$h_j$，它是一个$n$维向量，即：
$$
h_j = (h_{1j},h_{2j}, \cdots, h_{nj})^T \\
h_{i j}=\left\{\begin{array}{ll}{0} &amp; {v_{i} \notin A_{j}} \\ {\frac{1}{\sqrt{\left|A_{j}\right|}}} &amp; {v_{i} \in A_{j}}\end{array}\right.
$$
$h_ij$表示节点$v_i$ 是否属于子图$A_j$, 如果属于，那么$h_{ij} = \frac{1}{\sqrt{\left|A_{j}\right|}}$，如果不属于，那么$h_{ij} = 0$。</p>
<p>那么对于$h_i^TLh_i$有：
$$
\begin{aligned}
h_i^T L h_i &amp;= \frac{1}{2}\sum_{m=1}\sum_{n=1}w_{mn}(h_{im}-h_{in})^2\\
&amp;= \frac{1}{2}\left(\sum_{m\in A_i}\sum_{n \in A_i}w_{mn}(h_{im}-h_{in})^2+\sum_{m\in A_i}\sum_{n \notin A_i}w_{mn}(h_{im}-h_{in})^2 + \\
\sum_{m\notin A_i}\sum_{n \in A_i}w_{mn}(h_{im}-h_{in})^2 + \sum_{m\notin A_i}\sum_{n \notin A_i}w_{mn}(h_{im}-h_{in})^2\right)\\
&amp; 上式中的mn是图中任意选取的两个不同的节点， 针对子图A_i及其对应的指示向量h_i,\\
&amp;任意选取的节点对有四种情况。其中 根据h_{ij}的定义，第一项和第四项为0，所以\\
&amp;=\frac{1}{2} \left(\sum_{m\in A_i}\sum_{n \notin A_i}w_{mn}(h_{im}-h_{in})^2 +
\sum_{m\notin A_i}\sum_{n \in A_i}w_{mn}(h_{im}-h_{in})^2\right) \\
&amp;=\frac{1}{2} \left(\sum_{m\in A_i}\sum_{n \notin A_i}w_{mn}(\frac{1}{\sqrt{\left|A_{i}\right|}})^2 +
\sum_{m\notin A_i}\sum_{n \in A_i}w_{mn}(-\frac{1}{\sqrt{\left|A_{i}\right|}})^2\right) \\
&amp;=\frac{1}{2}\left(\frac{1}{|A_i|}Cut(A_i,\overline{A_i}) + \frac{1}{|A_i|}Cut(A_i,\overline{A_i})\right)\\
&amp;=\frac{Cut(A_i,\overline{A_i})}{|A_i|} = RatioCut(A_i)
\end{aligned}
$$
上式$h_i^TLh_i$可以看做是子图$A_i$的RatioCut，那么：
$$
\begin{aligned}
RatioCut(A_1,A_2,\cdots,A_k) &amp;=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \overline{A_i}\right)}{\left|A_{i}\right|}  = \sum_{i = 1}^k \frac{Cut(A_i,\overline{A_i})}{|A_i|} \\
&amp;= \sum_{i=1}^k h_i^TLh^i = \sum_{i=1}^k (H^TLH)_{ii} = tr(H^TLH)
\end{aligned}
$$
每个$h_i^TLh^j$的值对应于矩阵$H^TLH$在位置$ij$处的值：
$$
H=(h_1,h_2,\cdots,h_k) \in \mathbb{R}^{n\times k}
$$
$$
h_i^TLh_j = (H^TLH)_{ij} \to h^T_iLh_i = (H^TLH)_{ii}
$$</p>
<p>由于$h_i\cdot h_j = 0, h_i \cdot h_i = 1$, 所以$H^TH = I$是一个单位矩阵</p>
<p>所以切图优化函数为：
$$
\underbrace{\arg \min }_{H} RatioCut\left(A_1,A_2,\cdots A_k\right) = \underbrace{\arg \min }_{H} \operatorname{tr}\left(H^{T} L H\right) \quad \text { s.t. } \quad H^{T} H=I
$$
$H$中的每个指示向量$h$是$n$维的，每个向量中的元素有两种取值，分别是0和$\frac{1}{\sqrt{\left|A_{j}\right|}}$， 所以每个$h$有$2^n$种可能性，所以整个$H$有$k2^n$中，因此上述目标函数是个NP-hard问题。</p>
<p>注意到$tr(H^TLH)$中每个优化子目标$h_i^TLh_i$，其中，$h$是单位正交基，基每个元素的平方和等于1，$L$为对称矩阵，<strong>此时$h^T_iLh_i$的最大值为$L$的最大特征值， $h^T_iLh_i$的最小值是$L$的最小特征值</strong>。在谱聚类中，我们的目标是找到目标函数的最小特征值，从而使目标函数最小，得到对应的特征向量。</p>
<p>对于$h^T_iLh_i$，目标是找到$L$最小的特征值，这个值就是$h^T_iLh_i$的最小值，对于$tr(H^TLH) = \sum^k_{i=1} h^T_iLh_i$，目标是找到$k$个最小的特征值，从而使$tr(H^TLH)$最小。</p>
<p>通过找到$L$最小的$k$个特征值，可以对应得到$k$个特征向量，这$k$个特征向量可以组成一个$n \times k$的矩阵，这个矩阵就是我们需要的指示向量矩阵$H$，里面包含了每个节点所属子图的信息。一般来说 我们需要对$H$按行做标准化：
$$
h_{ij}^* = \frac{h_{ij}}{\sqrt{\sum_{t=1}^kh^2_{it}}}
$$
注意到，$H$的每行是一个$k$维行向量，即$H_i = (H_{i1},H_{i2},\cdots, H_{ik})$， 表示节点$i$属于每个子图的指标值， 我们可以把$H_i$当做节点$v_i$的表示向量， 由于归一化后的$H$还不能明确指示各个样本的归属， 我们还需要对$H$代表的所有节点做一次传统聚类，如K-Means。</p>
<h2 id="ncut切图">NCut切图</h2>
<p>把$RatioCut$的分母从$|A_i|$换成$vol(A_i) = \sum_{j \in A_i}d_j$， 为$A_i$中所有节点的权重之和，一般来说$NCut$效果好于$RatioCut$:
$$
NCut(A_1,A_2,\cdots,A_k) = \frac{1}{2}\sum_{i=1}^k\frac{W(A_i,\overline{A_i})}{vol(A_i)} = \sum^k_{i = 1}\frac{Cut(A_i)}{vol(A_i)}
$$
$NCut$指示向量$h$做了改进，$RatioCut$切图在指示向量中使用$\frac{1}{\sqrt{|A_i|}}$表示某节点归属于子图$A_i$，而$NCut$切图使用子图权重$\frac{1}{\sqrt{vol{A_i}}}$来表示某节点归属子图$A_i$如下：
$$
h_{i j}=\left\{\begin{array}{ll}{0} &amp; {v_{i} \notin A_{j}} \\ {\frac{1}{\sqrt{v o l\left(A_{j}\right)}}} &amp; {v_{i} \in A_{j}}\end{array}\right.
$$
上式表示如果节点$v_i$在子图$A_j$中，那么指示向量$h_j$的第$i$个元素为$\frac{1}{\sqrt{vol{A_j}}}$。</p>
<p>那么对于$h_i^TLh_i$有：
$$
h^T_iLh_i = \frac{1}{2}\sum_{m=1}\sum_{n=1}w_{mn}(h_{im}-h_{in})^2 = \frac{Cut(A_i)}{vol(A_i)} =NCut(A_i)
$$
目标函数：
$$
NCut(A_i,A_2,\cdots,A_k) = \sum^k_{i = 1} NCut(A_i) = \sum^k_{i=1}h^T_iLh_i =\sum^k_{i=1}(H^TLH)_{ii} = tr(H^TLH)
$$
此时，$h_i \cdot h_j = 0$，$h_i\cdot h_i = \frac{|A_i|}{vol(A_i)} \neq 1$， 所以$H^TH \neq I$。</p>
<p>但是， 由于：$h^T_iDh_i = \sum^n_{j = 1} h_{ij}^2d_j$, $d_j$为节点$v_j$的权重和，$h_{ij}$的值表示节点j是否在子图$A_i$中，如果在子图$A_i$中，那么$h_{ij}^2 = \frac{1}{vol(A_i)}$，否则为0。</p>
<p>$$h^T_iDh_i = \frac{1}{vol(A_i)} \sum_{v_j \in A_i} d_j = \frac{1}{vol(A_i)} \cdot vol(A_i) = 1$$</p>
<p>最终目标函数为：
$$
\underbrace{\arg \min } _{H}\operatorname{tr}\left(H^{T} L H\right) \quad \text { s.t. }\quad H^{T} D H=I
$$
由于$H$中的指示向量$h$不是标准正交基，所以RatioCut中加粗的定理不能直接使用，所以，令$H = D^{-\frac{1}{2}}F$, $D^{-\frac{1}{2}}$表示对$D$对角线上元素开方后求逆，那么：
$$
H^TLH = F^TD^{-\frac{1}{2}}LD^{-\frac{1}{2}}F
$$</p>
<p>$$
H^TDH = F^TD^{-\frac{1}{2}}DD^{-\frac{1}{2}}F = F^TF=I
$$
所以目标函数转化为：
$$
\underbrace{\arg \min }_{F} \operatorname{tr}\left(F^{T} D^{-1 / 2} L D^{-1 / 2} F\right) \quad \text { s.t. } \quad F^{T} F=I
$$
同$RatioCut$，$D^{-1 / 2} L D^{-1 / 2}$是对称矩阵，$F$中的每个向量为标准正交基，只需要求出$D^{-1 / 2} L D^{-1 / 2}$的最小的前$k$个特征值，然后求出对应的特征向量，并标准化，最后得到特征矩阵$F$，然后对$F$的行向量做一次传统聚类，如K-means.</p>
<p>一般来说， $D^{-1 / 2} L D^{-1 / 2}$相当于对拉普拉斯矩阵$L$做了一次标准化，即$\frac{L_{i j}}{\sqrt{d_{i} * d_{j}}}$.</p>
<p>我把本文整理成了<a href="/posts/2019-09-07-spectral-clustering/Spectral-Cluster.pdf">PDF</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>深度学习中的优化算法总结</title>
      <link>https://JhuoW.github.io/posts/optimizer/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://JhuoW.github.io/posts/optimizer/</guid>
      <description>最近想好好学一学Deep Learning中的优化算法（不能一直Adam了），看了一些文献，用这篇文章做个总结笔记。
Gradient Desent(梯度下降) 目标函数$f(x)$，其中$x$为模型的待优化参数，对于每个epoch $t$, $\eta_t$表示第$t$个epoch的步长。$x_t$第$t$个epoch时的参数。
(1).梯度下降的原理：目标函数（损失函数）$f(x)$关于参数$x$的梯度是损失函数上升最快的方向。所以只要让$x$沿梯度的反方向走，就可以缩小目标函数。
(2).目标函数关于参数$x$在epoch $t$时的梯度：
$$g_t = \nabla_x f(x_t)$$
(3).我们要最小化$f(x)$, 所以参数$x$需要往梯度的反方向移动：
$$x_{t+1} = x_t-\eta_t g_t$$
其中$x_{t+1}$为$t+1$时刻的参数值。
Stochastic Gradient Desent(随机梯度下降) 梯度下降存在的问题有鞍点问题以及无法找到全局最优解的问题。所以引入SGD。
首先给出无偏估计的定义，稍后会用到：
无偏估计：估计量的均值等于真实值，即具体每一次估计值可能大于真实值，也可能小于真实值，而不能总是大于或小于真实值（这就产生了系统误差）。
深度学习中，目标函数通常是训练集中各个样本损失的平均，假设一个batch的大小为$n$，那么训练这个batch的损失就是$f_{batch}(x) = \frac{\displaystyle\sum_{i=1}^{n} f_i(x)}{n}$ , 所以目标函数对$x$的梯度就是：
$$\nabla f_{batch}(x) = \frac{1}{n} \displaystyle\sum_{i=1}^n \nabla f_i(x)$$
如果使用GD来优化：
$$x_{t+1} = x_{t}- \eta_t \frac{1}{n} \displaystyle\sum_{i=1}^n \nabla f_i(x) \ = x_t-\eta_t \nabla f_{batch}(x)$$ 上式可以看出，当训练样本非常大时，n也将边的非常大，那么梯度计算的计算开销就比较大。
随机梯度下降（SGD）的思想是： 以一个batch为例，这个batch中有n个样本，每个样本$i \in {1, \cdots,n}$, 每次从中随机选取一个样本来更新参数$x$。
$$x_{t+1} = x_{t}-\eta_t \nabla f_i(x)$$
这样就更新了一个batch的参数。 对比上面两个式子可以看出SGD降低了计算复杂度。上面两个式子是等价的，因为随机梯度$\nabla f_i(x)$是对梯度$\nabla f_{batch}(x)$的无偏估计，因为：</description>
      <content:encoded><![CDATA[<p>最近想好好学一学Deep Learning中的优化算法（不能一直Adam了），看了一些文献，用这篇文章做个总结笔记。</p>
<h1 id="gradient-desent梯度下降">Gradient Desent(梯度下降)</h1>
<p>目标函数$f(x)$，其中$x$为模型的待优化参数，对于每个epoch $t$, $\eta_t$表示第$t$个epoch的步长。$x_t$第$t$个epoch时的参数。<br>
(1).梯度下降的原理：目标函数（损失函数）$f(x)$关于参数$x$的梯度是损失函数上升最快的方向。所以只要让$x$沿梯度的反方向走，就可以缩小目标函数。<br>
(2).目标函数关于参数$x$在epoch $t$时的梯度：<br>
$$g_t = \nabla_x f(x_t)$$<br>
(3).我们要最小化$f(x)$, 所以参数$x$需要往梯度的反方向移动：<br>
$$x_{t+1} = x_t-\eta_t g_t$$<br>
其中$x_{t+1}$为$t+1$时刻的参数值。</p>
<h2 id="stochastic-gradient-desent随机梯度下降">Stochastic Gradient Desent(随机梯度下降)</h2>
<p>梯度下降存在的问题有鞍点问题以及无法找到全局最优解的问题。所以引入SGD。<br>
首先给出无偏估计的定义，稍后会用到：<br>
<a href="https://www.cnblogs.com/notwice/p/8538539.html">无偏估计</a>：估计量的均值等于真实值，即具体每一次估计值可能大于真实值，也可能小于真实值，而不能总是大于或小于真实值（这就产生了系统误差）。</p>
<p>深度学习中，目标函数通常是训练集中各个样本损失的平均，假设一个batch的大小为$n$，那么训练这个batch的损失就是$f_{batch}(x) = \frac{\displaystyle\sum_{i=1}^{n} f_i(x)}{n}$ , 所以目标函数对$x$的梯度就是：<br>
$$\nabla f_{batch}(x) = \frac{1}{n} \displaystyle\sum_{i=1}^n \nabla f_i(x)$$<br>
如果使用GD来优化：<br>
$$x_{t+1} = x_{t}- \eta_t \frac{1}{n} \displaystyle\sum_{i=1}^n \nabla f_i(x) \ = x_t-\eta_t \nabla f_{batch}(x)$$
上式可以看出，当训练样本非常大时，n也将边的非常大，那么梯度计算的计算开销就比较大。</p>
<p>随机梯度下降（SGD）的思想是： 以一个batch为例，这个batch中有n个样本，每个样本$i \in {1, \cdots,n}$, 每次从中随机选取一个样本来更新参数$x$。<br>
$$x_{t+1} = x_{t}-\eta_t \nabla f_i(x)$$<br>
这样就更新了一个batch的参数。 对比上面两个式子可以看出SGD降低了计算复杂度。上面两个式子是等价的，因为随机梯度$\nabla f_i(x)$是对梯度$\nabla f_{batch}(x)$的无偏估计，因为：<br>
$$E_i \nabla f_i(\boldsymbol{x}) = \frac{1}{n} \sum_{i = 1}^n \nabla f_i(\boldsymbol{x}) = \nabla f_{batch}(\boldsymbol{x})$$<br>
符合无偏估计的定义。</p>
<h2 id="momentum动量法">Momentum(动量法)</h2>
<h3 id="exponentially-weighted-moving-averagesema">Exponentially weighted moving averages(EMA)</h3>
<p>EMA,指数加权移动平均数。</p>
<p>在GD中,如果学习率过大，会导致目标函数发散，而无法逼近最小值，如下图所示：<br>
<img loading="lazy" src="/posts/2019-02-28-Optimizer/images/EMA_1.png" alt="1"  />
<br>
如果学习率很低，那么会缓慢接近最优点，如下图红色轨迹：<br>
<img loading="lazy" src="/posts/2019-02-28-Optimizer/images/EMA_2.png" alt="2"  />
<br>
我们希望在学习率较小的时候可以更快逼近最优点，在学习率大的时候自变量可以不发散，即在正确的方向上加速下降并且抑制震荡，也就是达到如下的效果：<br>
<img loading="lazy" src="/posts/2019-02-28-Optimizer/images/EMA_3.png" alt="3"  />
</p>
<p>因此引入EMA。给定参数$0 \leq \gamma &lt; 1$,当前时间步$t$的变量$y_t$是上一时间步$t-1$的变量$y_{t-1}$和当前时间步另一变量$x_t$的线性组合。<br>
$$y_t = \gamma y_{t-1} + (1-\gamma) x_t$$<br>
展开上式:<br>
$$\begin{split}\begin{aligned}
y_t  &amp;= (1-\gamma) x_t + \gamma y_{t-1}\\
&amp;= (1-\gamma)x_t + (1-\gamma) \cdot \gamma x_{t-1} + \gamma^2y_{t-2}\\
&amp;= (1-\gamma)x_t + (1-\gamma) \cdot \gamma x_{t-1} + (1-\gamma) \cdot \gamma^2x_{t-2} + \gamma^3y_{t-3}\\
&amp;\ldots
\end{aligned}\end{split}$$<br>
上式可以看出当前时刻变量是对过去时刻变量做指数加权，离当前时刻越近，加权越大（越接近1）。<br>
在现实中，我们将$y_t$看作是最近$1/(1-\gamma)$个时间步的$x_t$的加权平均，当$\gamma = 0.95$时，是最近20个时间步的$x_t$值的加权平均。当$\gamma=0.9$时,可以看做是最近10个时间步加权平均。</p>
<h3 id="动量法">动量法</h3>
<p>$$\begin{split}\begin{aligned}
\boldsymbol{v}_t &amp;= \gamma \boldsymbol{v}_{t-1} + \eta_t \boldsymbol{g}_t, \\
\boldsymbol{x}_t &amp;= \boldsymbol{x}_{t-1} - \boldsymbol{v}_t,
\end{aligned}\end{split}$$<br>
其中$g_t = \nabla f_i(x)$上式可以看出，如果$\gamma=0$，则上式就是一个普通的随机梯度下降法。$0 \leq \gamma &lt; 1$. $\gamma$一般取0.9。<br>
一般，初始化$v_0=0$, 则<br>
$$v_1=\eta_t g_t \\ v_2=\gamma v_1+\eta_t g_t = \eta_t g_t(\gamma+1) \\ v_3 = \eta_t g_t (\gamma^2+\gamma+1) \\ v_{inf} = \frac{(\eta_t g_t)\cdot(1-\gamma^{inf+1})}{1-\gamma}\approx \frac{(\eta_t g_t)}{1-\gamma}$$</p>
<p>相比原始梯度下降算法，动量梯度下降算法有助于加速收敛。当梯度与动量方向一致时，动量项会增加，而相反时，动量项减少，因此动量梯度下降算法可以减少训练的震荡过程。</p>
<p>换种方式理解动量法：<br>
<img loading="lazy" src="/posts/2019-02-28-Optimizer/images/m.jpg" alt="4"  />
<br>
如上图所示，A点为起始点，首先计算A点的梯度$\nabla a$，下降到B点，<br>
$$\theta_{new} = \theta-\eta\nabla a$$<br>
其中$\theta$为参数， $\eta$为学习率<br>
到达B点后要加上A点的梯度，但是A点的梯度有个衰减值$\gamma$,推荐取0.9，相当于加上一个来自A点递减的加速度。这样的做法可以让早期的梯度对当前梯度的影响越来越小，如果没有衰减值，模型往往会震荡难以收敛，甚至发散。所以B点的参数更新公式是这样的：<br>
$$v_t = \gamma v_{t-1}+\eta \nabla b$$<br>
$$\theta_{new} = \theta-v_t$$<br>
其中$v_{t-1}$表示之前所有步骤累计的动量和，$\nabla b$为B点的梯度方向。这样一步一步下去，带着初速度的小球就会极速的奔向谷底。</p>
<h1 id="adagrad">AdaGrad</h1>
<p>假设目标函数有两个参数分别为$x_1$,$x_2$,若梯度下降迭代过程中，始终使用相同的学习率$\eta$:<br>
$$x_{1_{new}} = x_1-\eta \frac{\partial f}{\partial x_1}$$
$$x_{2_{new}} = x_2-\eta \frac{\partial f}{\partial x_2}$$<br>
AdaGard算法根据自变量在每个维度的梯度值来调整各个维度上的学习率，避免学习率难以适应维度的问题。adagrad方法是将每一个参数的每一次迭代的梯度取平方累加再开方，用基础学习率除以这个数，来做学习率的动态更新。<br>
$\nabla_{\theta_i} J(\theta)$表示第$i$个参数的梯度，其中$\theta=(\theta_1,\theta_2,&hellip;)$有$n$个参数。如果使用SGD来优化第$i$个参数，我们可以表示为:<br>
$$\theta_{i_new} = \theta_i-\eta \nabla_{\theta_i}J(\theta)$$<br>
如果使用Adagrad，则可以表示为这样:<br>
$$\theta_{i,t+1}=\theta_{i,t}-\frac{\eta}{\sqrt{G_{i,t}+\epsilon}} \nabla_{\theta_{i,t}}J(\theta)$$<br>
$i,t$ 表示优化参数$\theta_i$时的第$t$次迭代，$\epsilon$防止分母为0，可以取$10^{-6}$,$G_{i,t}$表示对参数$\theta_i$优化的前$t$步的梯度的累加：<br>
$$G_{i,t} = G_{i,t-1}+\nabla_{\theta_{i,t}}J(\theta) $$<br>
新公式可以简化成:<br>
$$\theta_{t+1}= \theta_t-\frac{\eta}{\sqrt{G_t+\epsilon}}\nabla_{\theta_t}J(\theta)$$<br>
可以从上式看出，随着迭代的推移，新的学习率$\frac{\eta}{\sqrt{G_t+\epsilon}}$在缩小，说明Adagrad一开始激励收敛，到了训练的后期惩罚收敛，收敛速度变慢</p>
<h1 id="rmsprop">RMSprop</h1>
<p>主要解决Adagrad学习率过快衰减问题，类似动量的思想，引入一个超参数，在积累梯度平方项进行衰减.<br>
$$s = \gamma \cdot s +(1-\gamma) \cdot \nabla J(\theta) \odot \nabla J(\theta) $$<br>
参数$\theta$的迭代目标函数可以改写为:<br>
$$\theta_{new} = \theta - \frac{\eta}{\sqrt{s+\varepsilon}} \odot \nabla J(\theta)$$<br>
可以看出$s$是梯度的平方的指数加权移动平均值，$\gamma$一般取0.9，有助于解决 Adagrad中学习率下降过快的情况。</p>
<h2 id="adaptive-moment-estimationadam">Adaptive moment estimation(Adam)</h2>
<p>Adam可以说是用的最多的优化算法，Adam通过计算一阶矩估计和二阶矩估计为不同的参数设计独立的自适应学习率。</p>
<h2 id="adabound">Adabound</h2>
<p>正在学习中</p>
<p>参考文献：<br>
<a href="https://zhuanlan.zhihu.com/p/32626442">https://zhuanlan.zhihu.com/p/32626442</a><br>
<a href="https://zhuanlan.zhihu.com/p/31630368">https://zhuanlan.zhihu.com/p/31630368</a><br>
<a href="https://zh.gluon.ai/">https://zh.gluon.ai/</a><br>
<a href="https://blog.csdn.net/tsyccnh/article/details/76270707">https://blog.csdn.net/tsyccnh/article/details/76270707</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
